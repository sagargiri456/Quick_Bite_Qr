
----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\api\create-table\route.ts -----

// File: app/api/create-table/route.ts
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    const { restaurantId, tableNumber } = await req.json();

    // Call your Supabase Edge Function
const res = await fetch(
  "https://melkeknoniqnnlanhobo.functions.supabase.co/generate-table-qr",
  {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`, 
      // or SUPABASE_SERVICE_ROLE_KEY if you want more power (be careful!)
    },
    body: JSON.stringify({ restaurantId, tableNumber }),
  }
);

    if (!res.ok) {
      const errorText = await res.text();
      return NextResponse.json(
        { error: `Supabase function failed: ${errorText}` },
        { status: res.status }
      );
    }

    const data = await res.json();

    return NextResponse.json({ success: true, ...data });
  } catch (err: any) {
    return NextResponse.json(
      { error: err.message || "Unknown error" },
      { status: 500 }
    );
  }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\api\push\notify\route.ts -----

import { NextResponse } from 'next/server';
import webpush from 'web-push';
import { createServerClient } from '@/lib/supabase/server';

const VAPID_PUBLIC_KEY = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!;
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY!;
const VAPID_SUBJECT = process.env.VAPID_SUBJECT || 'mailto:admin@example.com';

webpush.setVapidDetails(VAPID_SUBJECT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY);

/**
 * POST body: { orderId, title, body, url? }
 * Sends to all subscriptions bound to the order
 */
export async function POST(req: Request) {
  try {
    const { orderId, title, body, url } = await req.json();
    if (!orderId) return NextResponse.json({ error: 'orderId required' }, { status: 400 });

    const supabase = await createServerClient();
    const { data: subs, error } = await supabase
      .from('web_push_subscriptions')
      .select('*')
      .eq('order_id', orderId);

    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    const payload = JSON.stringify({ title: title || 'Order update', body: body || '', data: { url } });

    const results = await Promise.allSettled(
      (subs || []).map(async (s) => {
        const subscription = {
          endpoint: s.endpoint,
          keys: { p256dh: s.p256dh, auth: s.auth }
        } as any;
        try {
          await webpush.sendNotification(subscription, payload);
          return { ok: true };
        } catch (err: any) {
          // If gone, consider deleting the subscription
          if (err?.statusCode === 404 || err?.statusCode === 410) {
            await supabase.from('web_push_subscriptions').delete().eq('endpoint', s.endpoint);
          }
          return { ok: false, error: err?.message };
        }
      })
    );

    return NextResponse.json({ ok: true, results });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });
  }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\api\push\subscribe\route.ts -----

import { NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';

export async function POST(req: Request) {
  try {
    const { orderId, subscription } = await req.json();
    if (!orderId || !subscription?.endpoint) {
      return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
    }

    const p256dh = subscription.keys?.p256dh;
    const auth = subscription.keys?.auth;

    const supabase = await createServerClient();
    // Upsert by endpoint to avoid duplicates
    const { error } = await supabase
      .from('web_push_subscriptions')
      .upsert({
        order_id: orderId,
        endpoint: subscription.endpoint,
        p256dh, auth
      }, { onConflict: 'endpoint' });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Unknown error' }, { status: 500 });
  }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\api\uploadthing\core.ts -----

// src/app/api/uploadthing/core.ts
import { createUploadthing, type FileRouter } from "uploadthing/next";

const f = createUploadthing();

// This is a fake user ID - in a real app, you'd get this from your auth solution
const auth = (_req: Request) => ({ id: "fake-user-id" }); 

// FileRouter for your app, can contain multiple FileRoutes
export const ourFileRouter = {
  // Define as many FileRoutes as you like, each with a unique route slug
  menuItemImage: f({ image: { maxFileSize: "4MB", maxFileCount: 1 } })
    // Set permissions and file types for this FileRoute
    .middleware(async ({ req }) => {
      // This code runs on your server before upload
      const user = await auth(req);
    

      // If you throw, the user will not be able to upload
      if (!user) throw new Error("Unauthorized");

      // Whatever is returned here is accessible in onUploadComplete
      return { userId: user.id };
    })
    .onUploadComplete(async ({ metadata, file }) => {
      // This code RUNS ON YOUR SERVER after upload
      console.log("Upload complete for userId:", metadata.userId);
      console.log("file url", file.url);
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\api\uploadthing\route.ts -----

// src/app/api/uploadthing/route.ts
import { createRouteHandler } from "uploadthing/next"; // CHANGED: Correct import
import { ourFileRouter } from "./core";

// Export routes for Next App Router
export const { GET, POST } = createRouteHandler({ // CHANGED: Correct function name
  router: ourFileRouter,
});

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\PublicPagesComponents\Cart.tsx -----

'use client';

import { useState } from 'react';
import { useCartStore } from '@/app/customer-end-pages/store/cartStore';
import CartItem from './CartItem';
import { X, ShoppingCart, Loader2 } from 'lucide-react';
import { submitOrder } from '@/lib/api/orders';
import { useRouter } from 'next/navigation';

interface CartProps {
  isOpen: boolean;
  onClose: () => void;
  restaurantId: string;
  tableId: string;
  restaurantSlug: string;
}

const formatPrice = (price: number) =>
  new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(price);

export default function Cart({ isOpen, onClose, restaurantId, tableId, restaurantSlug }: CartProps) {
  const router = useRouter();
  const { items, totalPrice, clearCart } = useCartStore();
  const [isPlacingOrder, setIsPlacingOrder] = useState(false);
  const [orderSuccess, setOrderSuccess] = useState(false);

  const handlePlaceOrder = async () => {
    setIsPlacingOrder(true);
    try {
      const total = totalPrice();
      // The submitOrder function now returns the necessary details for redirection
      const { success, trackCode, restaurantSlug: slug } = await submitOrder(items, restaurantId, tableId, total);

      if (success && trackCode && slug) {
        setOrderSuccess(true);
        clearCart();
        // Redirect to the correct order tracking page
        router.push(`/customer-end-pages/${slug}/orders/${trackCode}`);
        return;
      }
      
      alert('Order could not be placed. Please try again.');
    } catch (error) {
      console.error(error);
      alert('There was an error placing your order. Please try again.');
    } finally {
      setIsPlacingOrder(false);
    }
  };

  const handleClose = () => {
    onClose();
    setTimeout(() => setOrderSuccess(false), 300);
  };

  return (
    <>
      {/* Backdrop */}
      <div
        className={`fixed inset-0 bg-black transition-opacity duration-300 ${
          isOpen ? 'opacity-50' : 'opacity-0 pointer-events-none'
        } z-[1190]`}
        onClick={handleClose}
      />

      {/* Drawer */}
      <div
        className={`fixed top-0 right-0 h-full w-full max-w-md bg-white shadow-2xl transform transition-transform duration-300 ease-in-out ${
          isOpen ? 'translate-x-0' : 'translate-x-full'
        } z-[1200]`}
      >
        <div className="flex flex-col h-full">
          <div className="flex justify-between items-center p-6 border-b">
            <h2 className="text-2xl font-bold text-gray-800">Your Cart</h2>
            <button onClick={handleClose} className="p-2 rounded-full hover:bg-gray-100">
              <X size={24} />
            </button>
          </div>

          {/* Content */}
          {orderSuccess ? (
            <div className="flex flex-col items-center justify-center h-full text-center text-gray-700 p-6">
              <h3 className="text-2xl font-bold text-green-600">Order Placed!</h3>
              <p className="mt-2">Redirecting to tracking pageâ€¦</p>
            </div>
          ) : (
            <>
              <div className="flex-grow p-6 overflow-y-auto">
                {items.length === 0 ? (
                  <div className="flex flex-col items-center justify-center h-full text-center text-gray-500">
                    <ShoppingCart size={48} className="mb-4" />
                    <p className="font-semibold">Your cart is currently empty.</p>
                  </div>
                ) : (
                  <div className="divide-y">
                    {items.map((item) => (
                      <CartItem key={item.id} item={item} />
                    ))}
                  </div>
                )}
              </div>

              {items.length > 0 && (
                <div className="p-6 border-t bg-gray-50">
                  <div className="flex justify-between items-center mb-4">
                    <span className="text-lg font-semibold text-gray-800">Subtotal</span>
                    <span className="text-xl font-bold text-gray-900">
                      {formatPrice(totalPrice())}
                    </span>
                  </div>
                  <button
                    onClick={handlePlaceOrder}
                    disabled={isPlacingOrder}
                    className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 flex items-center justify-center"
                  >
                    {isPlacingOrder && <Loader2 className="mr-2 h-5 w-5 animate-spin" />}
                    {isPlacingOrder ? 'Placing Order...' : 'Place Order'}
                  </button>
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\PublicPagesComponents\CartItem.tsx -----

'use client';

import Image from 'next/image';
import { useCartStore, CartItem as CartItemType } from '@/app/customer-end-pages/store/cartStore';
import { Plus, Minus, X } from 'lucide-react';

interface CartItemProps {
  item: CartItemType;
}

const formatPrice = (price: number) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(price);

export default function CartItem({ item }: CartItemProps) {
  const { addItem, removeItem } = useCartStore();

  return (
    <div className="flex items-center gap-4 py-4">
      <div className="relative h-16 w-16 rounded-lg overflow-hidden">
        {item.photo_url ? (
          <Image src={item.photo_url} alt={item.name} layout="fill" objectFit="cover" />
        ) : (
          <div className="bg-gray-200 h-full w-full"></div>
        )}
      </div>
      <div className="flex-grow">
        <p className="font-semibold text-gray-800">{item.name}</p>
        <p className="text-sm text-gray-600">{formatPrice(item.price)}</p>
      </div>
      <div className="flex items-center gap-2">
        <button onClick={() => removeItem(item.id)} className="p-1 rounded-full bg-gray-200 hover:bg-gray-300">
          {item.quantity > 1 ? <Minus size={14} /> : <X size={14} />}
        </button>
        <span className="font-bold w-6 text-center">{item.quantity}</span>
        <button onClick={() => addItem(item)} className="p-1 rounded-full bg-gray-200 hover:bg-gray-300">
          <Plus size={14} />
        </button>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\PublicPagesComponents\CustomerMenuItemCard.tsx -----

'use client';

import Image from 'next/image';
import { MenuItem } from '@/types/menu';
import { Plus } from 'lucide-react';
// CORRECTED: Import from the new co-located path
import { useCartStore } from '../store/cartStore'; 

const formatPrice = (price: number) => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(price);
};

interface CustomerMenuItemCardProps {
  item: MenuItem;
}

export default function CustomerMenuItemCard({ item }: CustomerMenuItemCardProps) {
  const { addItem } = useCartStore();

  return (
    <div className="bg-white rounded-2xl shadow-lg overflow-hidden flex flex-col group transition-all duration-300 hover:shadow-2xl">
      <div className="relative h-48 w-full">
        {item.photo_url ? (
          <Image
            src={item.photo_url}
            alt={item.name}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-300 group-hover:scale-105"
          />
        ) : (
          <div className="bg-gray-100 h-full w-full flex items-center justify-center">
            <span className="text-gray-400">No Image</span>
          </div>
        )}
      </div>
      <div className="p-4 flex-grow flex flex-col">
        <h3 className="text-lg font-bold text-gray-800">{item.name}</h3>
        <p className="text-sm text-gray-600 mt-1 flex-grow">{item.description}</p>
        <div className="flex justify-between items-center mt-4">
          <p className="text-xl font-bold text-gray-900">{formatPrice(item.price)}</p>
          <button 
            onClick={() => addItem(item)}
            className="flex items-center gap-2 bg-blue-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
          >
            <Plus size={16} />
            Add
          </button>
        </div>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\store\cartStore.ts -----

import { create } from 'zustand';
import { MenuItem } from '@/types/menu';

export interface CartItem extends MenuItem {
  quantity: number;
}

interface CartState {
  items: CartItem[];
  addItem: (item: MenuItem) => void;
  removeItem: (itemId: number) => void;
  clearCart: () => void;
  totalItems: () => number;
  totalPrice: () => number;
}

export const useCartStore = create<CartState>((set, get) => ({
  items: [],
  addItem: (item) => {
    const currentItems = get().items;
    const existingItem = currentItems.find((cartItem) => cartItem.id === item.id);
    if (existingItem) {
      const updatedItems = currentItems.map((cartItem) =>
        cartItem.id === item.id ? { ...cartItem, quantity: cartItem.quantity + 1 } : cartItem
      );
      set({ items: updatedItems });
    } else {
      set({ items: [...currentItems, { ...item, quantity: 1 }] });
    }
  },
  removeItem: (itemId) => {
    const currentItems = get().items;
    const existingItem = currentItems.find((cartItem) => cartItem.id === itemId);
    if (existingItem && existingItem.quantity > 1) {
      const updatedItems = currentItems.map((cartItem) =>
        cartItem.id === itemId ? { ...cartItem, quantity: cartItem.quantity - 1 } : cartItem
      );
      set({ items: updatedItems });
    } else {
      set({ items: currentItems.filter((cartItem) => cartItem.id !== itemId) });
    }
  },
  clearCart: () => set({ items: [] }),
  totalItems: () => get().items.reduce((total, item) => total + item.quantity, 0),
  totalPrice: () => get().items.reduce((total, item) => total + item.price * item.quantity, 0),
}));

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\[restaurantSlug]\orders\[code]\page.tsx -----

import { createServerClient } from '@/lib/supabase/server';
import StatusClient from './StatusClient';
import { notFound } from 'next/navigation';

type PageProps = {
  params: {
    restaurantSlug: string;
    // FIX: This must be lowercase to match the folder name '[code]'
    code: string;
  };
};

export default async function OrderTrackPage({ params }: PageProps) {
  // FIX: Destructuring is now simple and direct
  const { restaurantSlug, code } = params;
  const supabase = await createServerClient();

  // Step 1: Fetch order by tracking code
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .select('id, track_code, status, estimated_time, created_at, restaurant_id')
    .eq('track_code', code)
    .single();

  if (orderError || !order) {
    console.log(`Order not found for code: ${code}.`);
    notFound();
  }

  // Step 2: Fetch the associated restaurant
  if (!order.restaurant_id) {
    console.error(`CRITICAL: Order ${order.id} is missing a restaurant_id.`);
    return <div className="p-8 text-center text-red-600">Error: Order data is corrupted.</div>;
  }

  const { data: restaurant, error: restaurantError } = await supabase
    .from('restaurants')
    .select('restaurant_name, slug')
    .eq('id', order.restaurant_id)
    .single();

  if (restaurantError || !restaurant) {
    console.error(`CRITICAL: Restaurant not found for id: ${order.restaurant_id}.`);
    return <div className="p-8 text-center text-red-600">Error: Could not find restaurant information.</div>;
  }

  // Step 3: Validate the URL slug
  if (restaurant.slug !== restaurantSlug) {
    console.warn(`Slug mismatch. URL: "${restaurantSlug}", DB: "${restaurant.slug}"`);
    notFound();
  }

  // All data is valid, now render the client component with the correct props.
  return (
    <StatusClient
      trackCode={order.track_code}
      restaurantName={restaurant.restaurant_name}
      orderId={order.id} // Re-added orderId for push notifications
      initialStatus={order.status}
      initialEta={order.estimated_time}
      createdAt={order.created_at}
    />
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\[restaurantSlug]\orders\[code]\StatusClient.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase/client';
import OrderStatusTimeline from '@/components/orders/OrderStatusTimeline';
import StatusBadge from '@/components/orders/StatusBadge';
import ETA from '@/components/orders/ETA';
import FormattedDate from '@/components/FormattedDate';
import { registerPushForOrder } from '@/lib/utils/notifications'; // 1. Import the notification utility

// Defines the props this component receives from the page
type StatusClientProps = {
  trackCode: string;
  restaurantName: string;
  orderId: string; // 2. Ensure orderId is received for the subscription
  initialStatus: string;
  initialEta: number | null;
  createdAt: string;
};

const dbToUiStatus = (dbStatus: string): 'Pending' | 'Confirmed' | 'Preparing' | 'Ready' | 'Complete' | 'Cancelled' => {
  const statusMap = {
    pending: 'Pending', confirmed: 'Confirmed', preparing: 'Preparing',
    ready: 'Ready', complete: 'Complete', cancelled: 'Cancelled',
  } as const;
  return statusMap[dbStatus as keyof typeof statusMap] || 'Pending';
};

export default function StatusClient({
  trackCode,
  restaurantName,
  orderId, // Receive orderId
  initialStatus,
  initialEta,
  createdAt,
}: StatusClientProps) {
  const [status, setStatus] = useState(dbToUiStatus(initialStatus));
  const [eta, setEta] = useState<number | null>(initialEta);

  // 3. ADD THIS EFFECT TO TRIGGER PUSH SUBSCRIPTION
  useEffect(() => {
    // When the component first loads, ask for permission and register
    // for push notifications for this specific order.
    registerPushForOrder(orderId);
  }, [orderId]);

  // This effect handles real-time page updates via Supabase channels
  useEffect(() => {
    const channel = supabase
      .channel(`order-${trackCode}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE', schema: 'public', table: 'orders',
          filter: `track_code=eq.${trackCode}`,
        },
        (payload) => {
          const row = payload.new as any;
          if (row?.status) setStatus(dbToUiStatus(row.status));
          if ('estimated_time' in row) setEta(row.estimated_time);
        }
      )
      .subscribe();

    return () => { supabase.removeChannel(channel); };
  }, [trackCode]);

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-2xl mx-auto px-4">
        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
          <div className="text-center mb-6">
            <h1 className="text-3xl font-bold text-gray-900 mb-2">Order Status</h1>
            <p className="text-gray-600">Track your order in real-time</p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div className="space-y-3">
              <div>
                <span className="text-sm font-medium text-gray-500">Tracking Code</span>
                <p className="text-lg font-semibold text-gray-900">{trackCode}</p>
              </div>
              <div>
                <span className="text-sm font-medium text-gray-500">Restaurant</span>
                <p className="text-lg font-semibold text-gray-900 capitalize">{restaurantName}</p>
              </div>
              <div>
                <span className="text-sm font-medium text-gray-500">Order Placed</span>
                <p className="text-lg font-semibold text-gray-900">
                  <FormattedDate dateString={createdAt} />
                </p>
              </div>
            </div>

            <div className="space-y-3">
              <div>
                <span className="text-sm font-medium text-gray-500">Current Status</span>
                <div className="mt-1">
                  <StatusBadge status={status} />
                </div>
              </div>
              <div>
                <span className="text-sm font-medium text-gray-500">Estimated Time</span>
                <ETA
                  currentStatus={status}
                  etaMinutes={eta}
                />
              </div>
            </div>
          </div>
          <OrderStatusTimeline currentStatus={status} />
        </div>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\[restaurantSlug]\[tableId]\page.tsx -----

'use client';

import React, { useState, useEffect } from 'react';
import { useParams } from 'next/navigation';

// API functions
import { getPublicMenuItems, getRestaurantDetails } from '@/lib/api/public';

// Components
import CustomerMenuItemCard from '@/app/customer-end-pages/PublicPagesComponents/CustomerMenuItemCard';
import Cart from '@/app/customer-end-pages/PublicPagesComponents/Cart';

// Store
import { useCartStore } from '@/app/customer-end-pages/store/cartStore';

// Types
import { MenuItem as BaseMenuItem, MenuCategory } from '@/types/menu';

// Icons
import { ShoppingCart, Search, Loader2 } from 'lucide-react';

interface RestaurantDetails {
  id: string;
  restaurant_name: string;
}

interface MenuItem extends BaseMenuItem {
  category?: MenuCategory;
}

export default function CustomerMenuPage() {
  const { restaurantSlug, tableId } = useParams<{ restaurantSlug: string; tableId: string }>();

  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [restaurantDetails, setRestaurantDetails] = useState<RestaurantDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isCartOpen, setIsCartOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');

  const { totalItems } = useCartStore();

  useEffect(() => {
    if (!restaurantSlug) return;

    const fetchData = async () => {
      setIsLoading(true);
      try {
        const [items, details] = await Promise.all([
          getPublicMenuItems(restaurantSlug),
          getRestaurantDetails(restaurantSlug),
        ]);

        setMenuItems(items || []);
        if (details) setRestaurantDetails(details);
      } catch (error) {
        console.error('Failed to fetch menu data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [restaurantSlug]);

  const filteredItems = menuItems.filter(
    (item) => item.name && item.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const groupedMenu = filteredItems.reduce((acc, item) => {
    const category = (item.category as MenuCategory) || 'mains';
    if (!acc[category]) acc[category] = [];
    acc[category].push(item);
    return acc;
  }, {} as Record<MenuCategory, MenuItem[]>);

  const categoryOrder: MenuCategory[] = ['starters', 'mains', 'desserts', 'drinks'];

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <Loader2 className="h-12 w-12 animate-spin text-blue-600" />
      </div>
    );
  }

  return (
    <div className="bg-gray-50 min-h-screen font-sans">
      <div className="max-w-7xl mx-auto pb-12">
        <header className="sticky top-0 bg-white/80 backdrop-blur-md z-50 p-4 shadow-sm">
          <div className="flex justify-between items-center mb-4">
            <h1 className="text-2xl sm:text-3xl font-bold text-gray-900">
              {restaurantDetails ? restaurantDetails.restaurant_name : 'Menu'}
            </h1>
            <button
              onClick={() => setIsCartOpen(true)}
              className="relative bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 transition-colors duration-200"
            >
              <ShoppingCart size={20} />
              {totalItems() > 0 && (
                <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs font-bold rounded-full h-5 w-5  flex items-center justify-center animate-bounce">
                  {totalItems()}
                </span>
              )}
            </button>
          </div>

          <div className="relative">
            <Search
              className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"
              size={20}
            />
            <input
              type="text"
              placeholder="Search menu items..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-shadow duration-200"
            />
          </div>
        </header>

        <main className="p-4">
          {!restaurantDetails || filteredItems.length === 0 ? (
            <div className="text-center mt-20">
              <p className="text-xl text-gray-600">
                {searchQuery
                  ? `No menu items found for "${searchQuery}".`
                  : "This restaurant's menu is not available right now."}
              </p>
            </div>
          ) : (
            <div className="space-y-12">
              {categoryOrder.map(
                (category) =>
                  groupedMenu[category] &&
                  groupedMenu[category].length > 0 && (
                    <section key={category}>
                      <h2 className="text-2xl sm:text-3xl font-bold text-gray-800 capitalize mb-6 ">
                        {category}
                      </h2>
                      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl-grid-cols-4 gap-6">
                        {groupedMenu[category].map((item) => (
                          <CustomerMenuItemCard key={item.id} item={item} />
                        ))}
                      </div>
                    </section>
                  )
              )}
            </div>
          )}
        </main>
      </div>

      {restaurantDetails && (
        <>
          {/* pass slug so Cart can redirect to /orders/[orderId] */}
          <Cart
            isOpen={isCartOpen}
            onClose={() => setIsCartOpen(false)}
            restaurantId={restaurantDetails.id}
            tableId={String(tableId)}
            restaurantSlug={String(restaurantSlug)}
          />
        </>
      )}
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\customer-end-pages\[restaurantSlug]\page.tsx -----

// src/app/customer-end-pages/[restaurantSlug]/page.tsx

import { getRestaurantBySlug } from "@/lib/api/public";
import { Scan } from 'lucide-react';
import Link from "next/link";

// This page now serves as a guide for users who land on the restaurant slug URL without a table ID.
export default async function RestaurantLandingPage({ params }: { params: { restaurantSlug: string } }) {

  const restaurant = await getRestaurantBySlug(params.restaurantSlug);

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <div className="max-w-md w-full text-center bg-white p-8 rounded-2xl shadow-lg">
        <Scan size={60} className="mx-auto text-blue-500 mb-6" />
        <h1 className="text-3xl font-bold text-gray-800 mb-2">
          Welcome to {restaurant?.restaurant_name || 'Our Restaurant'}!
        </h1>
        <p className="text-gray-600 text-lg mb-8">
          To view the menu and place an order, please scan the QR code located at your table.
        </p>
        <div className="bg-blue-50 p-4 rounded-lg">
          <p className="font-semibold text-blue-800">
            Looking for the dashboard?
          </p>
          <Link href="/login" className="text-blue-600 hover:underline">
            Restaurant Login
          </Link>
        </div>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\menus\page.tsx -----

"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import Image from "next/image";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Utensils, Plus, Edit, Eye, Search, TrendingUp, DollarSign, Star } from "lucide-react";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from "recharts";

// Sample menu data with images
const menus = [
  {
    id: "1",
    name: "Dinner Menu",
    description: "Our signature dinner experience featuring seasonal ingredients",
    category: "Main Menu",
    status: "Active",
    items: 24,
    avgPrice: 28.50,
    lastUpdated: "2024-01-20",
    popularity: 95,
    seasonal: true,
    chef: "Chef Michael",
    cuisine: "Contemporary American",
    image: "/images/restaurant-ambiance.jpg"
  },
  {
    id: "2",
    name: "Lunch Specials",
    description: "Quick and delicious lunch options for busy professionals",
    category: "Special Menu",
    status: "Active",
    items: 12,
    avgPrice: 18.75,
    lastUpdated: "2024-01-22",
    popularity: 88,
    seasonal: false,
    chef: "Chef Sarah",
    cuisine: "International Fusion",
    image: "https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=400&h=300&fit=crop&auto=format"
  },
  {
    id: "3",
    name: "Weekend nien",
    description: "Indulgent brunch offerings for weekend relaxation",
    category: "Special Menu",
    status: "Active",
    items: 18,
    avgPrice: 22.40,
    lastUpdated: "2024-01-19",
    popularity: 92,
    seasonal: true,
    chef: "Chef Emma",
  
    image: "https://images.unsplash.com/photo-1551218808-94e220e796d9?w=400&h=300&fit=crop&auto=format"
  },
  {
    id: "4",
    name: "Holiday Feast",
    description: "Festive holiday menu with traditional favorites",
    category: "Seasonal Menu",
    status: "Inactive",
    items: 15,
    avgPrice: 45.00,
    lastUpdated: "2023-12-15",
    popularity: 78,
    seasonal: true,
    chef: "Chef David",
    cuisine: "Traditional Holiday",
    image: "/images/holiday-feast.jpg"
  },
  {
    id: "5",
    name: "Happy Hour",
    description: "Appetizers and drinks for evening socializing",
    category: "Bar Menu",
    status: "Active",
    items: 8,
    avgPrice: 12.50,
    lastUpdated: "2024-01-18",
    popularity: 85,
    seasonal: false,
    chef: "Chef Lisa",
    cuisine: "Bar & Appetizers",
    image: "/images/bar-appetizers.jpg"
  },
  {
    id: "6",
    name: "Kids Menu",
    description: "Family-friendly options for our youngest guests",
    category: "Special Menu",
    status: "Active",
    items: 6,
    avgPrice: 14.25,
    lastUpdated: "2024-01-21",
    popularity: 82,
    seasonal: false,
    chef: "Chef Anna",
    cuisine: "Family Friendly",
    image: "https://images.unsplash.com/photo-1504674900240-8947e31be9f6?w=400&h=300&fit=crop&auto=format"
  }
];

// Chart data
const menuPerformanceData = [
  { menu: "Dinner", revenue: 2840, orders: 95, avgRating: 4.6 },
  { menu: "Lunch", revenue: 1680, orders: 88, avgRating: 4.4 },
  { menu: "Brunch", revenue: 2016, orders: 92, avgRating: 4.5 },
  { menu: "Holiday", revenue: 675, orders: 78, avgRating: 4.3 },
  { menu: "Happy Hour", revenue: 1000, orders: 85, avgRating: 4.2 },
  { menu: "Kids", revenue: 855, orders: 82, avgRating: 4.1 }
];

const categoryDistribution = [
  { name: "Main Menu", value: 35, color: "#0088FE" },
  { name: "Special Menu", value: 30, color: "#00C49F" },
  { name: "Seasonal Menu", value: 20, color: "#FFBB28" },
  { name: "Bar Menu", value: 15, color: "#FF8042" }
];

const statusColors = {
  "Active": "bg-green-100 text-green-800 border-green-200",
  "Inactive": "bg-gray-100 text-gray-800 border-gray-200",
  "Draft": "bg-yellow-100 text-yellow-800 border-yellow-200",
  "Archived": "bg-red-100 text-red-800 border-red-200"
};

export default function MenusPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const [categoryFilter, setCategoryFilter] = useState("All");
  const [statusFilter, setStatusFilter] = useState("All");
  const [cuisineFilter, setCuisineFilter] = useState("All");

  // Filter menus based on search and filters
  const filteredMenus = useMemo(() => {
    return menus.filter(menu => {
      const searchMatch = 
        menu.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        menu.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        menu.chef.toLowerCase().includes(searchTerm.toLowerCase());
      
      const categoryMatch = categoryFilter === "All" || menu.category === categoryFilter;
      const statusMatch = statusFilter === "All" || menu.status === statusFilter;
      const cuisineMatch = cuisineFilter === "All" || menu.cuisine === cuisineFilter;
      
      return searchMatch && categoryMatch && statusMatch && cuisineMatch;
    });
  }, [searchTerm, categoryFilter, statusFilter, cuisineFilter]);

  // Calculate analytics
  const analytics = useMemo(() => {
    const totalMenus = menus.length;
    const activeMenus = menus.filter(m => m.status === "Active").length;
    const totalItems = menus.reduce((sum, m) => sum + m.items, 0);
    const avgPrice = menus.reduce((sum, m) => sum + m.avgPrice, 0) / totalMenus;
    const totalRevenue = menus.reduce((sum, m) => sum + (m.avgPrice * m.popularity), 0);
    const avgPopularity = menus.reduce((sum, m) => sum + m.popularity, 0) / totalMenus;
    
    return {
      totalMenus,
      activeMenus,
      totalItems,
      avgPrice,
      totalRevenue,
      avgPopularity
    };
  }, [menus]);

  return (
    <div className="min-h-[80vh] px-4 sm:px-6 lg:px-8 py-8">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h1 className="text-2xl sm:text-3xl font-bold text-slate-800 flex items-center gap-3">
            <span className="p-2 rounded-lg bg-green-600 text-white">
              <Utensils className="w-5 h-5" />
            </span>
            Menu Management & Analytics
          </h1>
          <div className="flex gap-2">
            <Button variant="outline" size="sm">
              <Plus className="w-4 h-4 mr-2" />
              Create Menu
            </Button>
            <Link href="/" className="text-blue-600 hover:underline">
              <Button variant="outline" size="sm">Back to Dashboard</Button>
            </Link>
          </div>
        </div>

        {/* Key Metrics */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <Card className="border-green-100 bg-green-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-green-100 rounded-lg">
                  <Utensils className="w-4 h-4 text-green-600" />
                </div>
                <div>
                  <div className="text-sm text-green-600 mb-1">Total Menus</div>
                  <div className="text-2xl font-bold text-green-800">{analytics.totalMenus}</div>
                  <div className="text-xs text-green-600">{analytics.activeMenus} active</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-blue-100 bg-blue-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 rounded-lg">
                  <TrendingUp className="w-4 h-4 text-blue-600" />
                </div>
                <div>
                  <div className="text-sm text-blue-600 mb-1">Total Items</div>
                  <div className="text-2xl font-bold text-blue-800">{analytics.totalItems}</div>
                  <div className="text-xs text-blue-600">Across all menus</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-yellow-100 bg-yellow-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-yellow-100 rounded-lg">
                  <DollarSign className="w-4 h-4 text-yellow-600" />
                </div>
                <div>
                  <div className="text-sm text-yellow-600 mb-1">Avg. Price</div>
                  <div className="text-2xl font-bold text-yellow-800">${analytics.avgPrice.toFixed(2)}</div>
                  <div className="text-xs text-yellow-600">Per menu item</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-purple-100 bg-purple-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-purple-100 rounded-lg">
                  <Star className="w-4 h-4 text-purple-600" />
                </div>
                <div>
                  <div className="text-sm text-purple-600 mb-1">Avg. Popularity</div>
                  <div className="text-2xl font-bold text-purple-800">{analytics.avgPopularity.toFixed(0)}%</div>
                  <div className="text-xs text-purple-600">Customer satisfaction</div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Charts Row */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Menu Performance Chart */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-slate-800">Menu Performance</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={menuPerformanceData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="menu" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Bar dataKey="revenue" fill="#3B82F6" name="Revenue ($)" />
                  <Bar dataKey="orders" fill="#10B981" name="Orders" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>

          {/* Category Distribution */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-slate-800">Menu Categories</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={categoryDistribution}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    label={({ name, percent = 0 }) => `${name} ${(percent * 100).toFixed(0)}%`}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                  >
                    {categoryDistribution.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={entry.color} />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </div>

        {/* Controls */}
        <Card>
          <CardContent className="p-4">
            <div className="flex flex-col sm:flex-row gap-4 items-center justify-between">
              <div className="relative flex-1 max-w-md">
                <Search className="w-4 h-4 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" />
                <Input 
                  placeholder="Search menus..." 
                  className="pl-9"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
              <div className="flex gap-2">
                <select 
                  value={categoryFilter}
                  onChange={(e) => setCategoryFilter(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Categories</option>
                  <option value="Main Menu">Main Menu</option>
                  <option value="Special Menu">Special Menu</option>
                  <option value="Seasonal Menu">Seasonal Menu</option>
                  <option value="Bar Menu">Bar Menu</option>
                </select>
                <select 
                  value={statusFilter}
                  onChange={(e) => setStatusFilter(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Status</option>
                  <option value="Active">Active</option>
                  <option value="Inactive">Inactive</option>
                  <option value="Draft">Draft</option>
                  <option value="Archived">Archived</option>
                </select>
                <select 
                  value={cuisineFilter}
                  onChange={(e) => setCuisineFilter(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Cuisines</option>
                  <option value="Contemporary American">Contemporary American</option>
                  <option value="International Fusion">International Fusion</option>
                  <option value="Modern Brunch">Modern Brunch</option>
                  <option value="Traditional Holiday">Traditional Holiday</option>
                  <option value="Bar & Appetizers">Bar & Appetizers</option>
                  <option value="Family Friendly">Family Friendly</option>
                </select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Menus Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredMenus.map((menu) => (
            <Card key={menu.id} className="hover:shadow-lg transition-shadow duration-300 overflow-hidden">
              {/* Menu Image */}
              <div className="relative h-48 w-full overflow-hidden">
                <Image
                  src={menu.image}
                  alt={menu.name}
                  fill
                  className="object-cover transition-transform duration-300 hover:scale-105"
                  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  onError={(e) => {
                    // Fallback to a placeholder if image fails to load
                    const target = e.target as HTMLImageElement;
                    target.src = `/images/restaurant-ambiance.jpg`;
                  }}
                />
                {/* Status Badge Overlay */}
                <div className="absolute top-3 right-3">
                  <Badge 
                    variant="outline" 
                    className={`${statusColors[menu.status as keyof typeof statusColors]} border backdrop-blur-sm`}
                  >
                    {menu.status}
                  </Badge>
                </div>
                {/* Seasonal Badge Overlay */}
                {menu.seasonal && (
                  <div className="absolute top-3 left-3">
                    <Badge variant="outline" className="bg-orange-100 text-orange-800 border-orange-200 backdrop-blur-sm">
                      Seasonal
                    </Badge>
                  </div>
                )}
                {/* Items Count Overlay */}
                <div className="absolute bottom-3 left-3">
                  <div className="bg-white/90 backdrop-blur-sm px-3 py-1 rounded-full shadow-lg">
                    <span className="font-bold text-blue-600 text-sm">{menu.items} items</span>
                  </div>
                </div>
                {/* Avg Price Overlay */}
                <div className="absolute bottom-3 right-3">
                  <div className="bg-white/90 backdrop-blur-sm px-3 py-1 rounded-full shadow-lg">
                    <span className="font-bold text-green-600 text-sm">${menu.avgPrice}</span>
                  </div>
                </div>
              </div>

              <CardHeader className="pb-3">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <CardTitle className="text-lg font-bold text-slate-800 mb-1">{menu.name}</CardTitle>
                    <p className="text-sm text-slate-600 line-clamp-2">{menu.description}</p>
                  </div>
                </div>
              </CardHeader>
              
              <CardContent className="space-y-3">
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div>
                    <span className="text-slate-600">Category:</span>
                    <div className="font-medium">{menu.category}</div>
                  </div>
                  <div>
                    <span className="text-slate-600">Cuisine:</span>
                    <div className="font-medium">{menu.cuisine}</div>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Chef:</span>
                  <span className="font-medium">{menu.chef}</span>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Popularity:</span>
                  <div className="flex items-center gap-1">
                    <Star className="w-3 h-3 text-yellow-500 fill-current" />
                    <span className="font-medium">{menu.popularity}%</span>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Updated:</span>
                  <span className="font-medium">{menu.lastUpdated}</span>
                </div>
                
                <div className="flex gap-2 pt-2">
                  <Button variant="outline" size="sm" className="flex-1">
                    <Eye className="w-3 h-3 mr-1" />
                    View
                  </Button>
                  <Button variant="outline" size="sm" className="flex-1">
                    <Edit className="w-3 h-3 mr-1" />
                    Edit
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Summary Stats */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Card className="border-indigo-100 bg-indigo-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-indigo-600 mb-1">Menu Categories</div>
                <div className="text-2xl font-bold text-indigo-800">4</div>
                <div className="text-xs text-indigo-600">
                  Main, Special, Seasonal, Bar
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-emerald-100 bg-emerald-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-emerald-600 mb-1">Seasonal Menus</div>
                <div className="text-2xl font-bold text-emerald-800">3</div>
                <div className="text-xs text-emerald-600">
                  Dinner, Brunch, Holiday
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-amber-100 bg-amber-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-amber-600 mb-1">Total Revenue</div>
                <div className="text-2xl font-bold text-amber-800">
                  ${analytics.totalRevenue.toFixed(0)}
                </div>
                <div className="text-xs text-amber-600">
                  From all active menus
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\menu_items\page.tsx -----

"use client";

import { useState, useMemo } from "react";
import Link from "next/link";
import Image from "next/image";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Soup, Plus, Edit, Eye, Search, TrendingUp, DollarSign, Clock, Star, Flame } from "lucide-react";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from "recharts";
import { useEffect } from "react";

import { supabase } from "@/lib/supabase/client"; 


type MenuItem = {
  id: string;
  name: string;
  description: string;
  price: number;
  category: string;
  photo_url?: string;
  available?: boolean;
  created_at?: string;
  // Additional properties for the UI
  status?: string;
  image?: string;
  subcategory?: string;
  cost?: number;
  profit?: number;
  chef?: string;
  preparationTime?: number;
  calories?: number;
  popularity?: number;
  orders?: number;
  rating?: number;
  dietary?: string[];
  allergens?: string[];
  seasonal?: boolean;
};


// Chart data
const itemPerformanceData = [
  { item: "Grilled Salmon", revenue: 5070, orders: 156, profit: 2145 },
  { item: "Truffle Pasta", revenue: 3752, orders: 134, profit: 2077 },
  { item: "Caesar Salad", revenue: 3118, orders: 189, profit: 1937 },
  { item: "Beef Tenderloin", revenue: 4410, orders: 98, profit: 2205 },
  { item: "Chocolate Lava", revenue: 2421, orders: 167, profit: 1628 },
  { item: "Mushroom Risotto", revenue: 2912, orders: 112, profit: 1680 }
];

const categoryRevenue = [
  { name: "Main Course", value: 65, color: "#0088FE" },
  { name: "Appetizer", value: 20, color: "#00C49F" },
  { name: "Dessert", value: 15, color: "#FFBB28" }
];

const statusColors = {
  "Active": "bg-green-100 text-green-800 border-green-200",
  "Inactive": "bg-gray-100 text-gray-800 border-gray-200",
  "Draft": "bg-yellow-100 text-yellow-800 border-yellow-200",
  "Seasonal": "bg-orange-100 text-orange-800 border-orange-200"
};

const dietaryColors = {
  "Vegetarian": "bg-green-100 text-green-800 border-green-200",
  "Vegan": "bg-emerald-100 text-emerald-800 border-emerald-200",
  "Gluten-Free": "bg-blue-100 text-blue-800 border-blue-200",
  "Low-Carb": "bg-purple-100 text-purple-800 border-purple-200",
  "Dairy-Free": "bg-yellow-100 text-yellow-800 border-yellow-200"
};

export default function MenuItemsPage() {
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [searchTerm, setSearchTerm] = useState("");
  const [categoryFilter, setCategoryFilter] = useState("All");
  const [statusFilter, setStatusFilter] = useState("All");
  const [priceRange, setPriceRange] = useState("All");


  useEffect(() => {
    const fetchMenuItems = async () => {
      const { data, error } = await supabase
        .from("menu_items")
        .select("*")
        .order("created_at", { ascending: false });
        // console.log(data);

      if (error) {
        console.error("Error fetching menu items:", error);
      } else {
        setMenuItems(data || []);
      }
    };

    fetchMenuItems();
  }, []);


  // Filter menu items based on search and filters
  const filteredItems = useMemo(() => {
    return menuItems.filter(item => {
      const searchMatch = 
        item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.description.toLowerCase().includes(searchTerm.toLowerCase());
      
      const categoryMatch = categoryFilter === "All" || item.category === categoryFilter;
      const statusMatch = statusFilter === "All" || item.status === statusFilter;
      
      let priceMatch = true;
      if (priceRange !== "All") {
        const [min, max] = priceRange.split("-").map(Number);
        priceMatch = item.price >= min && item.price <= max;
      }
      
      return searchMatch && categoryMatch && statusMatch && priceMatch;
    });
  }, [searchTerm, categoryFilter, statusFilter, priceRange, menuItems]);

  // Calculate analytics
  const analytics = useMemo(() => {
    const totalItems = menuItems.length;
    console.log(totalItems);
    const activeItems = menuItems.filter(i => i.status === "Active").length;
    const totalRevenue = menuItems.reduce((sum, i) => sum + (i.price * (i.orders || 0)), 0);
    const totalProfit = menuItems.reduce((sum, i) => sum + ((i.profit || 0) * (i.orders || 0)), 0);
    const avgPrice = totalItems > 0 ? menuItems.reduce((sum, i) => sum + i.price, 0) / totalItems : 0;
    const avgRating = totalItems > 0 ? menuItems.reduce((sum, i) => sum + (i.rating || 0), 0) / totalItems : 0;
    const totalOrders = menuItems.reduce((sum, i) => sum + (i.orders || 0), 0);
    
    return {
      totalItems,
      activeItems,
      totalRevenue,
      totalProfit,
      avgPrice,
      avgRating,
      totalOrders
    };
  }, [menuItems]);

  return (
    <div className="min-h-[80vh] px-4 sm:px-6 lg:px-8 py-8">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h1 className="text-2xl sm:text-3xl font-bold text-slate-800 flex items-center gap-3">
            <span className="p-2 rounded-lg bg-orange-600 text-white">
              <Soup className="w-5 h-5" />
            </span>
            Menu Items Management
          </h1>
          <div className="flex gap-2">
            <Button variant="outline" size="sm">
              <Plus className="w-4 h-4 mr-2" />
              Add Item
            </Button>
            <Link href="/" className="text-blue-600 hover:underline">
              <Button variant="outline" size="sm">Back to Dashboard</Button>
            </Link>
          </div>
        </div>

        {/* Key Metrics */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <Card className="border-orange-100 bg-orange-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-orange-100 rounded-lg">
                  <Soup className="w-4 h-4 text-orange-600" />
                </div>
                <div>
                  <div className="text-sm text-orange-600 mb-1">Total Items</div>
                  <div className="text-2xl font-bold text-orange-800">{analytics.totalItems}</div>
                  <div className="text-xs text-orange-600">{analytics.activeItems} active</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-green-100 bg-green-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-green-100 rounded-lg">
                  <TrendingUp className="w-4 h-4 text-green-600" />
                </div>
                <div>
                  <div className="text-sm text-green-600 mb-1">Total Revenue</div>
                  <div className="text-2xl font-bold text-green-800">${(analytics.totalRevenue / 1000).toFixed(1)}k</div>
                  <div className="text-xs text-green-600">From all items</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-blue-100 bg-blue-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 rounded-lg">
                  <DollarSign className="w-4 h-4 text-blue-600" />
                </div>
                <div>
                  <div className="text-sm text-blue-600 mb-1">Total Profit</div>
                  <div className="text-2xl font-bold text-blue-800">${(analytics.totalProfit / 1000).toFixed(1)}k</div>
                  <div className="text-xs text-blue-600">Net profit</div>
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-purple-100 bg-purple-50/50">
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-purple-100 rounded-lg">
                  <Star className="w-4 h-4 text-purple-600" />
                </div>
                <div>
                  <div className="text-sm text-purple-600 mb-1">Avg. Rating</div>
                  <div className="text-2xl font-bold text-purple-800">{analytics.avgRating.toFixed(1)}</div>
                  <div className="text-xs text-purple-600">Customer satisfaction</div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Charts Row */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Item Performance Chart */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-slate-800">Item Performance</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={itemPerformanceData}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="item" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Bar dataKey="revenue" fill="#3B82F6" name="Revenue ($)" />
                  <Bar dataKey="profit" fill="#10B981" name="Profit ($)" />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>

          {/* Category Revenue Distribution */}
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-slate-800">Revenue by Category</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <PieChart>
                  <Pie
                    data={categoryRevenue}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    label={({ name, percent }: { name: string; percent?: number }) => `${name} ${((percent || 0) * 100).toFixed(0)}%`}
                    outerRadius={80}
                    fill="#8884d8"
                    dataKey="value"
                  >
                    {categoryRevenue.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={entry.color} />
                    ))}
                  </Pie>
                  <Tooltip />
                </PieChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </div>

        {/* Controls */}
        <Card>
          <CardContent className="p-4">
            <div className="flex flex-col sm:flex-row gap-4 items-center justify-between">
              <div className="relative flex-1 max-w-md">
                <Search className="w-4 h-4 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" />
                <Input 
                  placeholder="Search menu items..." 
                  className="pl-9"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
              <div className="flex gap-2">
                <select 
                  value={categoryFilter}
                  onChange={(e) => setCategoryFilter(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Categories</option>
                  <option value="Appetizer">Appetizer</option>
                  <option value="Main Course">Main Course</option>
                  <option value="Dessert">Dessert</option>
                  <option value="Beverage">Beverage</option>
                </select>
                <select 
                  value={statusFilter}
                  onChange={(e) => setStatusFilter(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Status</option>
                  <option value="Active">Active</option>
                  <option value="Inactive">Inactive</option>
                  <option value="Seasonal">Seasonal</option>
                </select>
                <select 
                  value={priceRange}
                  onChange={(e) => setPriceRange(e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                >
                  <option value="All">All Prices</option>
                  <option value="0-20">$0 - $20</option>
                  <option value="20-35">$20 - $35</option>
                  <option value="35-50">$35 - $50</option>
                  <option value="50-100">$50+</option>
                </select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Menu Items Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {filteredItems.map((item) => (
            <Card key={item.id} className="hover:shadow-lg transition-shadow duration-300 overflow-hidden">
              {/* Food Image */}
              <div className="relative h-48 w-full overflow-hidden">
                <Image
                  src={item.image || item.photo_url || `/images/caesar-salad.jpg`}
                  alt={item.name}
                  fill
                  className="object-cover transition-transform duration-300 hover:scale-105"
                  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  onError={(e) => {
                    // Fallback to a placeholder if image fails to load
                    const target = e.target as HTMLImageElement;
                    target.src = `/images/caesar-salad.jpg`;
                  }}
                />
                {/* Status Badge Overlay */}
                <div className="absolute top-3 right-3">
                  <Badge 
                    variant="outline" 
                    className={`${statusColors[item.status as keyof typeof statusColors]} border backdrop-blur-sm`}
                  >
                    {item.status}
                  </Badge>
                </div>
                {/* Seasonal Badge Overlay */}
                {item.seasonal && (
                  <div className="absolute top-3 left-3">
                    <Badge variant="outline" className="bg-orange-100 text-orange-800 border-orange-200 backdrop-blur-sm">
                      Seasonal
                    </Badge>
                  </div>
                )}
                {/* Price Overlay */}
                <div className="absolute bottom-3 right-3">
                  <div className="bg-white/90 backdrop-blur-sm px-3 py-1 rounded-full shadow-lg">
                    <span className="font-bold text-green-600 text-lg">${item.price}</span>
                  </div>
                </div>
              </div>

              <CardHeader className="pb-3">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <CardTitle className="text-lg font-bold text-slate-800 mb-1">{item.name}</CardTitle>
                    <p className="text-sm text-slate-600 line-clamp-2">{item.description}</p>
                  </div>
                </div>
              </CardHeader>

              <CardContent className="space-y-3">
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div>
                    <span className="text-slate-600">Category:</span>
                    <div className="font-medium">{item.category}</div>
                  </div>
                  <div>
                    <span className="text-slate-600">Subcategory:</span>
                    <div className="font-medium">{item.subcategory}</div>
                  </div>
                  <div>
                    <span className="text-slate-600">Cost:</span>
                    <div className="font-medium text-red-600">${item.cost}</div>
                  </div>
                  <div>
                    <span className="text-slate-600">Profit:</span>
                    <div className="font-medium text-green-600">${item.profit}</div>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Chef:</span>
                  <span className="font-medium">{item.chef}</span>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Prep Time:</span>
                  <div className="flex items-center gap-1">
                    <Clock className="w-3 h-3 text-blue-500" />
                    <span className="font-medium">{item.preparationTime}m</span>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Calories:</span>
                  <div className="flex items-center gap-1">
                    <Flame className="w-3 h-3 text-orange-500" />
                    <span className="font-medium">{item.calories}</span>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Popularity:</span>
                  <div className="flex items-center gap-1">
                    <Star className="w-3 h-3 text-yellow-500 fill-current" />
                    <span className="font-medium">{item.popularity}%</span>
                  </div>
                </div>
                
                <div className="flex items-center justify-between text-sm">
                  <span className="text-slate-600">Orders:</span>
                  <span className="font-medium">{item.orders}</span>
                </div>
                
                {/* Dietary Information */}
                {item.dietary && item.dietary.length > 0 && (
                  <div className="flex flex-wrap gap-1">
                    {item.dietary.map((diet) => (
                      <Badge 
                        key={diet} 
                        variant="outline" 
                        className={`${dietaryColors[diet as keyof typeof dietaryColors]} text-xs`}
                      >
                        {diet}
                      </Badge>
                    ))}
                  </div>
                )}
                
                {/* Allergens */}
                {item.allergens && item.allergens.length > 0 && (
                  <div className="text-xs text-slate-500">
                    <span className="font-medium">Allergens:</span> {item.allergens.join(", ")}
                  </div>
                )}
                
                <div className="flex gap-2 pt-2">
                  <Button variant="outline" size="sm" className="flex-1">
                    <Eye className="w-3 h-3 mr-1" />
                    View
                  </Button>
                  <Button variant="outline" size="sm" className="flex-1">
                    <Edit className="w-3 h-3 mr-1" />
                    Edit
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Summary Stats */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Card className="border-indigo-100 bg-indigo-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-indigo-600 mb-1">Avg. Price</div>
                <div className="text-2xl font-bold text-indigo-800">${analytics.avgPrice.toFixed(2)}</div>
                <div className="text-xs text-indigo-600">
                  Per menu item
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-emerald-100 bg-emerald-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-emerald-600 mb-1">Total Orders</div>
                <div className="text-2xl font-bold text-emerald-800">{analytics.totalOrders}</div>
                <div className="text-xs text-emerald-600">
                  Across all items
                </div>
              </div>
            </CardContent>
          </Card>
          
          <Card className="border-amber-100 bg-amber-50/50">
            <CardContent className="p-4">
              <div className="text-center">
                <div className="text-sm text-amber-600 mb-1">Profit Margin</div>
                <div className="text-2xl font-bold text-amber-800">
                  {((analytics.totalProfit / analytics.totalRevenue) * 100).toFixed(1)}%
                </div>
                <div className="text-xs text-amber-600">
                  Overall profitability
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\orders\LiveOrders.tsx -----

'use client';

import React, { useEffect, useMemo, useState } from 'react';
import { supabase } from '@/lib/supabase/client';
import LiveOrdersComponent from '@/components/LiveOrdersComponent';
import { Input } from '@/components/ui/input';
import { AlertTriangle } from 'lucide-react';

export type OrderItemStatus = 'Pending' | 'Confirmed' | 'Preparing' | 'Ready' | 'Cancelled';

export interface OrderItem {
  id: string;
  quantity: number;
  price: number;
  status: OrderItemStatus | null;
  created_at: string;
  order: {
    id: string;
    track_code: string | null;
    table_id: string | null;
    table_number: string | null;
    restaurant: { id: string; name: string; user_id: string };
  };
  menu_item: { id: string; name: string };
}

const LiveOrders = () => {
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  const [liveOrders, setLiveOrders] = useState<OrderItem[]>([]);
  const [restaurantIds, setRestaurantIds] = useState<string[]>([]);
  const [activeStatus, setActiveStatus] = useState<OrderItemStatus | 'All'>('All');
  const [search, setSearch] = useState('');

  // ===== helpers =====
  const dbToUiStatus = (db: string | null): OrderItemStatus | null => {
    switch (db) {
      case 'pending': return 'Pending';
      case 'confirmed': return 'Confirmed';
      case 'preparing': return 'Preparing';
      case 'ready': return 'Ready';
      case 'cancelled': return 'Cancelled';
      default: return null;
    }
  };

  const formatDate = (iso: string) =>
    new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  const getTotalPrice = (orders: OrderItem[] | null) =>
    (orders ?? []).reduce((sum, o) => sum + o.price * o.quantity, 0);

  // ===== fetch all orders for restaurants owned by the logged-in user =====
  const fetchLiveOrders = async () => {
    setRefreshing(true);
    try {
      // 1) current user
      const { data: { user }, error: authErr } = await supabase.auth.getUser();
      if (authErr) throw authErr;
      if (!user) throw new Error('Not authenticated');

      // 2) restaurants owned by this user
      const { data: restaurants, error: restErr } = await supabase
        .from('restaurants')
        .select('id, restaurant_name, user_id')
        .eq('user_id', user.id);

      if (restErr) throw restErr;

      const ids = (restaurants ?? []).map(r => r.id);
      setRestaurantIds(ids);

      if (ids.length === 0) {
        setLiveOrders([]);
        setErrorMsg('âš ï¸ No restaurants found for your account.');
        return;
      }

      // 3) orders that belong only to those restaurants
      const { data, error } = await supabase
        .from('orders')
        .select(`
          id, track_code, status, created_at,
          table:tables ( id, table_number ),
          restaurant:restaurants ( id, restaurant_name, user_id ),
          order_items (
            id, quantity, price,
            menu_item:menu_items ( id, name )
          )
        `)
        .in('restaurant_id', ids)
        .in('status', ['pending','confirmed','preparing','ready','cancelled'])
        .order('created_at', { ascending: false });

      if (error) throw error;

      // 4) normalize â†’ one card per order item
      const normalized: OrderItem[] = (data || []).flatMap((order: any) =>
        (order.order_items || []).map((item: any) => ({
          id: item.id,
          quantity: item.quantity,
          price: item.price,
          status: dbToUiStatus(order.status),
          created_at: order.created_at,
          order: {
            id: order.id,
            track_code: order.track_code ?? null,
            table_id: order.table?.id ? String(order.table.id) : null,
            table_number: order.table?.table_number ?? null,
            restaurant: {
              id: order.restaurant?.id ?? '',
              name: order.restaurant?.restaurant_name ?? '',
              user_id: order.restaurant?.user_id ?? '',
            },
          },
          menu_item: {
            id: item.menu_item?.id ?? '',
            name: item.menu_item?.name ?? '',
          },
        }))
      );

      setLiveOrders(normalized);
      setErrorMsg(null);
    } catch (e: any) {
      console.error('[LiveOrders.fetch]', e);
      setErrorMsg(e?.message || 'Failed to load orders');
      setLiveOrders([]);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // initial load
  useEffect(() => { fetchLiveOrders(); }, []);

  // realtime: refresh when any order changes for the owner's restaurants
  useEffect(() => {
    if (!restaurantIds.length) return;

    const channels = restaurantIds.map((rid) =>
      supabase
        .channel(`orders-${rid}`)
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: 'orders', filter: `restaurant_id=eq.${rid}` },
          () => fetchLiveOrders()
        )
        .subscribe()
    );

    return () => {
      channels.forEach((ch) => supabase.removeChannel(ch));
    };
  }, [restaurantIds]);

  // status + search filter
  const filteredOrders = useMemo(() => {
    let orders = [...liveOrders];

    if (activeStatus !== 'All') {
      orders = orders.filter((o) => o.status === activeStatus);
    }

    if (search.trim()) {
      const q = search.toLowerCase();
      orders = orders.filter((o) =>
        (o.order.track_code || '').toLowerCase().includes(q) ||
        (o.order.table_number || '').toLowerCase().includes(q) ||
        (o.menu_item.name || '').toLowerCase().includes(q) ||
        (o.order.restaurant.name || '').toLowerCase().includes(q) ||
        (o.status || '').toLowerCase().includes(q)
      );
    }
    return orders;
  }, [liveOrders, activeStatus, search]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  return (
    <div>
      {/* Header + Search */}
      <div className="mb-4 flex flex-col sm:flex-row gap-3 sm:items-center sm:justify-between">
        <div>
          <h2 className="text-xl font-semibold">Live Orders</h2>
          {errorMsg && (
            <div className="mt-2 flex items-center gap-2 bg-red-100 border border-red-300 text-red-700 px-3 py-2 rounded-md text-sm">
              <AlertTriangle className="h-4 w-4" />
              <span>{errorMsg}</span>
            </div>
          )}
        </div>
        <Input
          placeholder="Search by track code, table, item, or status..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="max-w-md"
        />
      </div>

      <LiveOrdersComponent
        liveOrders={liveOrders}
        filteredOrders={filteredOrders}
        refreshing={refreshing}
        fetchLiveOrders={fetchLiveOrders}
        activeStatus={activeStatus}
        setActiveStatus={setActiveStatus}
        formatDate={formatDate}
        getTotalPrice={(orders) => getTotalPrice(orders)}
        errorMsg={errorMsg}
      />
    </div>
  );
};

export default LiveOrders;

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\orders\OrderHistory.tsx -----

"use client";

import { useMemo, useState } from "react";
import useSWR from "swr";
import Link from "next/link";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Clock, Search, X } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { format, differenceInHours } from "date-fns";
import { supabase } from "@/lib/supabase/client";

const statusOptions = ["All", "Ready", "Preparing", "Pending", "Delivered"];

const getStatusColor = (status: string) => {
  switch (status) {
    case "Ready":
      return "bg-green-100 text-green-800 border-green-200";
    case "Preparing":
      return "bg-yellow-100 text-yellow-800 border-yellow-200";
    case "Pending":
      return "bg-orange-100 text-orange-800 border-orange-200";
    case "Delivered":
      return "bg-blue-100 text-blue-800 border-blue-200";
    default:
      return "bg-gray-100 text-gray-800 border-gray-200";
  }
};

// ðŸ”¹ Fetcher for SWR (works with Supabase client)
const fetchOrders = async () => {
  const { data, error } = await supabase
    .from("orders")
    .select("id, table_id, status, total_amount, created_at")
    .order("created_at", { ascending: false });

  if (error) throw error;

  const now = new Date();
  return (data || []).filter((order) => {
    const createdAt = new Date(order.created_at);
    return differenceInHours(now, createdAt) >= 24;
  });
};

export default function OrderHistoryPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedStatus, setSelectedStatus] = useState("All");

  // ðŸ”¹ SWR handles caching + revalidation
  const { data: orders = [], isLoading } = useSWR("orders-history", fetchOrders, {
    revalidateOnFocus: true, // refresh when tab is focused
    dedupingInterval: 10000, // avoid duplicate fetches within 10s
  });

  // ðŸ”¹ Filter orders
  const filteredOrders = useMemo(() => {
    return orders.filter((order) => {
      const searchMatch =
        order.id.toLowerCase().includes(searchTerm.toLowerCase()) ||
        order.table_id.toString().includes(searchTerm.toLowerCase());

      const statusMatch =
        selectedStatus === "All" || order.status === selectedStatus;

      return searchMatch && statusMatch;
    });
  }, [orders, searchTerm, selectedStatus]);

  return (
    <div className="min-h-[80vh] px-4 sm:px-6 lg:px-8 py-8">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <h1 className="text-2xl sm:text-3xl font-bold text-slate-800 flex items-center gap-3">
            <span className="p-2 rounded-lg bg-slate-800 text-white">
              <Clock className="w-5 h-5" />
            </span>
            Order History
          </h1>
          <Link href="/" className="text-blue-600 hover:underline">
            Back to Dashboard
          </Link>
        </div>

        {/* Controls */}
        <Card>
          <CardContent className="p-4 flex flex-col sm:flex-row gap-4 justify-between">
            <div className="relative flex-1 max-w-md">
              <Search className="w-4 h-4 text-slate-400 absolute left-3 top-1/2 -translate-y-1/2" />
              <Input
                placeholder="Search orders..."
                className="pl-9"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
            <div className="flex gap-2">
              {statusOptions.map((status) => (
                <Button
                  key={status}
                  variant={selectedStatus === status ? "default" : "outline"}
                  size="sm"
                  onClick={() => setSelectedStatus(status)}
                >
                  {status}
                </Button>
              ))}
              {(searchTerm || selectedStatus !== "All") && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setSearchTerm("");
                    setSelectedStatus("All");
                  }}
                >
                  <X className="w-4 h-4 mr-1" /> Clear
                </Button>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Orders Table */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg font-semibold text-slate-800">
              Orders older than 24 hrs ({filteredOrders.length})
            </CardTitle>
          </CardHeader>
          <CardContent className="p-0">
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead className="bg-slate-50 border-b">
                  <tr>
                    <th className="p-4 text-left text-sm font-medium text-slate-600">Order ID</th>
                    <th className="p-4 text-left text-sm font-medium text-slate-600">Table</th>
                    <th className="p-4 text-left text-sm font-medium text-slate-600">Total</th>
                    <th className="p-4 text-left text-sm font-medium text-slate-600">Status</th>
                    <th className="p-4 text-left text-sm font-medium text-slate-600">Date & Time</th>
                  </tr>
                </thead>
                <tbody>
                  {isLoading ? (
                    // Skeleton rows
                    Array.from({ length: 5 }).map((_, i) => (
                      <tr key={i} className="animate-pulse">
                        <td className="p-4"><div className="h-4 w-24 bg-slate-200 rounded"></div></td>
                        <td className="p-4"><div className="h-4 w-12 bg-slate-200 rounded"></div></td>
                        <td className="p-4"><div className="h-4 w-16 bg-slate-200 rounded"></div></td>
                        <td className="p-4"><div className="h-4 w-20 bg-slate-200 rounded"></div></td>
                        <td className="p-4"><div className="h-4 w-32 bg-slate-200 rounded"></div></td>
                      </tr>
                    ))
                  ) : filteredOrders.length > 0 ? (
                    filteredOrders.map((order, index) => (
                      <tr
                        key={order.id}
                        className={`border-b hover:bg-slate-50/50 transition-colors ${
                          index % 2 === 0 ? "bg-white" : "bg-slate-25"
                        }`}
                      >
                        <td className="p-4 font-mono text-slate-800">{order.id}</td>
                        <td className="p-4">
                          <Badge variant="outline" className="font-mono">{order.table_id}</Badge>
                        </td>
                        <td className="p-4 font-semibold text-green-600">
                          ${order.total_amount.toFixed(2)}
                        </td>
                        <td className="p-4">
                          <Badge variant="outline" className={`${getStatusColor(order.status)} border`}>
                            {order.status}
                          </Badge>
                        </td>
                        <td className="p-4 text-sm text-slate-600">
                          {format(new Date(order.created_at), "MMM dd, yyyy p")}
                        </td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td colSpan={5} className="p-8 text-center text-slate-500">
                        <div className="flex flex-col items-center gap-2">
                          <Search className="w-8 h-8 text-slate-300" />
                          <p>No past orders found</p>
                        </div>
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\orders\page.tsx -----

// src/app/dashboard/orders/page.tsx
import React from 'react';
import LiveOrders from './LiveOrders';
import OrderHistory from './OrderHistory';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Separator } from '@/components/ui/separator';

export default function Orders() {
  return (
    <div className="mx-auto max-w-7xl px-4 py-6 md:px-6 lg:px-8">
      {/* Page header */}
      <div className="mb-6">
        <h1 className="text-2xl font-semibold tracking-tight">Orders</h1>
        <p className="text-sm text-muted-foreground">
          Monitor live orders and browse historical activity.
        </p>
      </div>

      <Separator className="mb-6" />

      {/* Content grid */}
      <div className="grid grid-cols-1 gap-6 xl:grid-cols-2">
        {/* Live Orders */}
        <Card className="shadow-sm">
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">Live Orders</CardTitle>
          </CardHeader>
          <CardContent className="p-0">
            {/* Make inner content scroll on small screens while keeping the card tidy */}
            <div className="max-h-[70vh] overflow-auto px-4 pb-4">
              <LiveOrders />
            </div>
          </CardContent>
        </Card>

        {/* Order History */}
        <Card className="shadow-sm">
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">Order History</CardTitle>
          </CardHeader>
          <CardContent className="p-0">
            <div className="max-h-[70vh] overflow-auto px-4 pb-4">
              <OrderHistory />
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\profile\page.tsx -----

// src/app/dashboard/profile/page.tsx

'use client';

import React, { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase/client';
import RestaurantProfile from '@/components/RestaurantProfile'; // Use the well-built component
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { AlertCircle } from 'lucide-react';
import type { Restaurant } from '@/lib/types/types'; // Import the correct type

export default function RestaurantProfilePage() {
  const [restaurant, setRestaurant] = useState<Restaurant | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchRestaurant = async () => {
      setLoading(true);
      setError(null);
      try {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
          throw new Error('You must be logged in to view this page.');
        }

        const { data, error: dbError } = await supabase
          .from('restaurants')
          .select('*')
          .eq('user_id', user.id)
          .single();

        if (dbError) {
          throw new Error('Could not fetch your restaurant profile. Please try again.');
        }

        if (data) {
          setRestaurant(data);
        } else {
          throw new Error('No restaurant profile found for your account.');
        }
      } catch (e: any) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    };

    fetchRestaurant();
  }, []);

  // Handler for updating the restaurant data
  const handleUpdateProfile = async (updatedData: Partial<Restaurant>) => {
    if (!restaurant) throw new Error("No restaurant to update.");

    const { data, error } = await supabase
      .from('restaurants')
      .update(updatedData)
      .eq('id', restaurant.id)
      .select()
      .single();

    if (error) {
      throw new Error(error.message);
    }

    // Update the local state to reflect the changes immediately
    setRestaurant(data as Restaurant);
  };

  if (loading) {
    return (
      <div className="space-y-4">
        <Skeleton className="h-24 w-full" />
        <Skeleton className="h-64 w-full" />
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    );
  }

  if (!restaurant) {
    return (
        <Alert>
          <AlertDescription>No restaurant profile was found.</AlertDescription>
        </Alert>
    );
  }

  return <RestaurantProfile restaurant={restaurant} onUpdate={handleUpdateProfile} />;
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\tables\add\page.tsx -----

// src/app/dashboard/tables/add/page.tsx

'use client';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { generateQR } from '@/lib/api/generateQR';
import { supabase } from '@/lib/supabase/client';
import { Skeleton } from '@/components/ui/skeleton';
import { Loader2 } from 'lucide-react';
import { Restaurant } from '@/lib/types/types'; // Using a shared type

export default function AddTablePage() {
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const router = useRouter();
  const [loading, setLoading] = useState<boolean>(true);
  const [restaurant, setRestaurant] = useState<Restaurant | null>(null);
  // FIX: Table identifier is a string, not just a number
  const [tableIdentifier, setTableIdentifier] = useState<string>('');
  const [generatedUrl, setGeneratedUrl] = useState<string | null>(null);

  useEffect(() => {
    const fetchRestaurant = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        setLoading(false);
        // Optionally, redirect to login
        router.push('/login');
        return;
      }

      const { data, error } = await supabase
        .from('restaurants')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (data) {
        setRestaurant(data);
      } else {
        console.error('Error fetching restaurant data:', error);
      }
      setLoading(false);
    };
    fetchRestaurant();
  }, [router]);

  // FIX: Make the handler async and use state directly
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!restaurant || !tableIdentifier.trim()) {
        alert("Restaurant data is missing or table name is empty.");
        return;
    }

    setIsSubmitting(true);
    setGeneratedUrl(null);

    try {
      // The API route calls the edge function to do all the work
      const qrUrl = await generateQR(restaurant.id, tableIdentifier);
      setGeneratedUrl(qrUrl);
      alert(`Successfully created table "${tableIdentifier}"!`);
      // You can now download the QR or navigate away
      router.push('/dashboard/tables');
    } catch (error: any) {
      console.error(error);
      alert(`Failed to create table: ${error.message}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleDownloadQR = () => {
    if (!generatedUrl) return;
    const link = document.createElement("a");
    link.href = generatedUrl;
    link.download = `table-${tableIdentifier.replace(/\s+/g, '-')}.png`;
    link.click();
  };

  if (loading) return <Skeleton className="h-64 w-full" />;
  if (!restaurant) return <p className="text-red-600">No restaurant profile found.</p>;

  return (
    <div className="p-4 sm:p-8">
      <div className="max-w-lg mx-auto">
        <div className="bg-white rounded-2xl shadow-md p-6 mb-8 flex items-center">
          <button
            onClick={() => router.back()}
            className="p-2 rounded-lg bg-indigo-500 text-white hover:bg-indigo-600 mr-4"
            aria-label="Go back"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>
          <div>
            <h1 className="text-3xl font-bold text-gray-800">Add New Table</h1>
            <p className="text-gray-600 mt-1">Create a new table and generate its QR code.</p>
          </div>
        </div>

        <form onSubmit={handleSubmit} className="bg-white p-8 rounded-2xl shadow-md space-y-6">
          <div>
            <label htmlFor="tableIdentifier" className="block text-lg font-semibold text-gray-700 mb-2">
              Table Name or Number
            </label>
            <input
              id="tableIdentifier"
              type="text"
              name="tableIdentifier"
              value={tableIdentifier}
              onChange={(e) => setTableIdentifier(e.target.value)}
              className="w-full text-lg p-3 border-2 border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500"
              placeholder="e.g., Patio Table 4 or 12"
              required
            />
          </div>
          <div className="flex justify-end gap-4 pt-4 border-t border-gray-200">
            <button
              type="button"
              onClick={() => router.back()}
              className="px-6 py-3 border-2 border-gray-300 rounded-xl text-gray-700 font-semibold hover:bg-gray-100"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold px-6 py-3 rounded-xl disabled:opacity-50 flex items-center justify-center"
            >
              {isSubmitting && <Loader2 className="mr-2 h-5 w-5 animate-spin" />}
              {isSubmitting ? 'Saving...' : 'Save Table'}
            </button>
          </div>
        </form>

        {generatedUrl && (
          <div className="mt-8 bg-white p-6 rounded-2xl shadow-md text-center">
            <h3 className="text-lg font-semibold mb-4">QR Code Generated!</h3>
            <img src={generatedUrl} alt="Generated QR Code" className="mx-auto h-40 w-40" />
            <button
              onClick={handleDownloadQR}
              className="mt-4 w-full bg-green-600 text-white font-bold py-3 rounded-lg hover:bg-green-700"
            >
              Download QR
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\tables\[id]\edit\page.tsx -----

// src/app/dashboard/tables/[id]/edit/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { supabase } from '@/lib/supabase/client';
import { Skeleton } from '@/components/ui/skeleton';
import { Loader2, Save } from 'lucide-react';
import { Table } from '@/lib/api/tables';

export default function EditTablePage() {
Â  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
Â  const [loading, setLoading] = useState<boolean>(true);
Â  const [table, setTable] = useState<Table | null>(null);
Â  const [tableIdentifier, setTableIdentifier] = useState<string>('');
Â  const router = useRouter();
Â  const params = useParams();
Â  const { id } = params;

Â  useEffect(() => {
Â  Â  const fetchTable = async () => {
Â  Â  Â  if (!id) return;
Â  Â  Â  setLoading(true);
Â  Â  Â  const { data, error } = await supabase
Â  Â  Â  Â  .from('tables')
Â  Â  Â  Â  .select('*')
Â  Â  Â  Â  .eq('id', id)
Â  Â  Â  Â  .single();

Â  Â  Â  if (error || !data) {
Â  Â  Â  Â  console.error('Error fetching table data:', error);
Â  Â  Â  Â  alert('Could not find the table to edit.');
Â  Â  Â  Â  router.push('/dashboard/tables');
Â  Â  Â  } else {
Â  Â  Â  Â  setTable(data);
Â  Â  Â  Â  setTableIdentifier(data.table_number);
Â  Â  Â  }
Â  Â  Â  setLoading(false);
Â  Â  };

Â  Â  fetchTable();
Â  }, [id, router]);

Â  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
Â  Â  e.preventDefault();
Â  Â  if (!table || !tableIdentifier.trim()) {
Â  Â  Â  alert("Table data is missing or table name is empty.");
Â  Â  Â  return;
Â  Â  }

Â  Â  setIsSubmitting(true);
Â  Â  try {
Â  Â  Â  const { error } = await supabase
Â  Â  Â  Â  .from('tables')
Â  Â  Â  Â  .update({ table_number: tableIdentifier })
Â  Â  Â  Â  .eq('id', table.id);

Â  Â  Â  if (error) throw error;

Â  Â  Â  alert(`Successfully updated table!`);
Â  Â  Â  router.push('/dashboard/tables');
Â  Â  } catch (error: any) {
Â  Â  Â  console.error(error);
Â  Â  Â  alert(`Failed to update table: ${error.message}`);
Â  Â  } finally {
Â  Â  Â  setIsSubmitting(false);
Â  Â  }
Â  };

Â  if (loading) return <Skeleton className="h-64 w-full" />;
Â  if (!table) return <p className="text-red-600">Table not found.</p>;

Â  return (
Â  Â  <div className="p-4 sm:p-8">
Â  Â  Â  <div className="max-w-lg mx-auto">
Â  Â  Â  Â  <div className="bg-white rounded-2xl shadow-md p-6 mb-8">
Â  Â  Â  Â  Â  <h1 className="text-3xl font-bold text-gray-800">Edit Table</h1>
Â  Â  Â  Â  Â  <p className="text-gray-600 mt-1">Update the name or number for this table.</p>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <form onSubmit={handleSubmit} className="bg-white p-8 rounded-2xl shadow-md space-y-6">
Â  Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  Â  <label htmlFor="tableIdentifier" className="block text-lg font-semibold text-gray-700 mb-2">
Â  Â  Â  Â  Â  Â  Â  Table Name or Number
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <input
Â  Â  Â  Â  Â  Â  Â  id="tableIdentifier"
Â  Â  Â  Â  Â  Â  Â  type="text"
Â  Â  Â  Â  Â  Â  Â  value={tableIdentifier}
Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setTableIdentifier(e.target.value)}
Â  Â  Â  Â  Â  Â  Â  className="w-full text-lg p-3 border-2 border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500"
Â  Â  Â  Â  Â  Â  Â  required
Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div className="flex justify-end gap-4 pt-4 border-t border-gray-200">
Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  type="button"
Â  Â  Â  Â  Â  Â  Â  onClick={() => router.back()}
Â  Â  Â  Â  Â  Â  Â  className="px-6 py-3 border-2 border-gray-300 rounded-xl text-gray-700 font-semibold hover:bg-gray-100"
Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  Cancel
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  <button
Â  Â  Â  Â  Â  Â  Â  type="submit"
Â  Â  Â  Â  Â  Â  Â  disabled={isSubmitting}
Â  Â  Â  Â  Â  Â  Â  className="bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold px-6 py-3 rounded-xl disabled:opacity-50 flex items-center justify-center"
Â  Â  Â  Â  Â  Â  >
Â  Â  Â  Â  Â  Â  Â  {isSubmitting ? <Loader2 className="mr-2 h-5 w-5 animate-spin" /> : <Save className="mr-2 h-4 w-4" />}
Â  Â  Â  Â  Â  Â  Â  {isSubmitting ? 'Saving...' : 'Save Changes'}
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </form>
Â  Â  Â  </div>
Â  Â  </div>
Â  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\tables\page.tsx -----

'use client';

import Link from 'next/link';
import { useTables } from '@/lib/hooks/useTables';
import QrCodeDisplay from '@/components/tables/QrCodeDisplay';
import { Plus, Trash2, Edit } from 'lucide-react';

export default function TablesPage() {
  const { tables, loading, deleteTable } = useTables();

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="w-12 h-12 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  return (
    <div className="p-4 sm:p-8">
      <div className="max-w-7xl mx-auto">
        <div className="bg-white rounded-2xl shadow-md p-6 mb-8 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
          <div>
            <h1 className="text-3xl font-bold text-gray-800">Table Management</h1>
            <p className="text-gray-600 mt-1">Add, view, and manage your restaurant&apos;s tables and QR codes.</p>
          </div>
          <Link 
            href="/dashboard/tables/add" 
            className="flex items-center gap-2 bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold px-6 py-3 rounded-xl hover:from-indigo-600 hover:to-blue-600 transition-all shadow-md hover:shadow-lg"
          >
            <Plus size={20} />
            Add New Table
          </Link>
        </div>
        
        {tables.length === 0 ? (
          <div className="text-center bg-white p-12 rounded-2xl shadow-md">
              <svg xmlns="http://www.w3.org/2000/svg" className="mx-auto h-16 w-16 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
              </svg>
              <h2 className="mt-4 text-2xl font-semibold text-gray-800">No tables found</h2>
              <p className="text-gray-500 mt-2">Get started by adding your first table to generate a QR code.</p>
          </div>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            {tables.map(table => (
              <div key={table.id} className="bg-white p-6 rounded-2xl shadow-md flex flex-col justify-between transition-all hover:shadow-xl hover:-translate-y-1">
                <h2 className="text-xl font-bold text-center text-gray-800 mb-4">{table.table_number}</h2>
                {table.qr_code_url && table.qr_code_url !== 'generating...' ? (
                  <QrCodeDisplay url={table.qr_code_url} tableName={table.table_number} />
                ) : (
                  <div className="flex items-center justify-center h-40 text-gray-500">
                    <div className="w-6 h-6 border-2 border-gray-300 border-t-transparent rounded-full animate-spin"></div>
                  </div>
                )}
                 <div className="flex justify-between items-center mt-4 pt-4 border-t">
                    <Link href={`/dashboard/tables/${table.id}/edit`} className="flex items-center gap-2 text-blue-600 hover:text-blue-800 font-medium transition-colors">
                        <Edit size={14} />
                        Edit
                    </Link>
                    <button onClick={() => deleteTable(table.id)} className="flex items-center gap-2 text-red-500 hover:text-red-700 font-medium transition-colors">
                        <Trash2 size={14} />
                        Delete
                    </button>
                 </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\layout.tsx -----

'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { usePathname, useRouter } from 'next/navigation';
import { Home, UtensilsCrossed, SquareKanban, LogOut, ListOrdered, ListPlus } from 'lucide-react';
import { logout } from '@/lib/auth/logout';
import { Providers } from './providers';

function NavItem({ href, label, icon: Icon }: { href: string; label: string; icon: React.ComponentType<{ size?: number }> }) {
  const pathname = usePathname();
  // Highlight parent nav item even on child pages (e.g., /tables/add should highlight Tables)
  // The dashboard link is a special case to avoid it being active on all pages.
  const isActive = href === '/dashboard' ? pathname === href : pathname.startsWith(href);

  return (
    <Link
      href={href}
      aria-current={isActive ? 'page' : undefined}
      className={`flex items-center gap-3 px-4 py-3 rounded-lg transition-all text-base font-medium ${
        isActive ? 'bg-indigo-600 text-white shadow-md' : 'text-gray-600 hover:bg-gray-100'
      }`}
    >
      <Icon size={22} />
      {label}
    </Link>
  );
}

export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const handleLogout = async () => {
    setLoading(true);
    try {
      await logout();
      router.push('/login'); // Corrected path
    } finally {
      setLoading(false);
    }
  };

  const navItems = [
    { href: '/dashboard', label: 'Home', icon: Home },
    { href: '/dashboard/orders', label: 'Orders', icon: ListOrdered },
    { href: '/dashboard/tables', label: 'Tables', icon: SquareKanban },
    { href: '/dashboard/menus', label: 'Menus', icon: UtensilsCrossed },
    { href: '/dashboard/menu_items', label: 'Menu Items', icon: ListPlus },
  ];

  return (
    <Providers>
      <div className="min-h-screen bg-gray-50 flex">
        <aside className="w-64 bg-white shadow-md flex flex-col">
          <div className="p-6 text-2xl font-bold text-indigo-600 border-b">QuickBite QR</div>
          <nav className="flex-1 p-4 space-y-2">
            {navItems.map((item) => (
              <NavItem key={item.href} {...item} />
            ))}
          </nav>
          <div className="p-4 border-t">
            <button
              onClick={handleLogout}
              disabled={loading}
              aria-label="Logout"
              className="flex items-center gap-3 w-full px-4 py-3 rounded-lg text-base font-medium text-red-500 hover:bg-red-50 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <LogOut size={22} />
              {loading ? 'Logging out...' : 'Log Out'}
            </button>
          </div>
        </aside>
        <main className="flex-1 p-8 overflow-auto">{children}</main>
      </div>
    </Providers>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\page.tsx -----

'use client'

import { useEffect, useState } from "react"
import { motion } from "framer-motion"
import { DashboardNavCards } from "@/components/DashboardNavCards"
import { LiveOrderNotification } from "@/components/LiveOrderNotification"
import { RecentOrders } from "@/components/RecentOrders" // CORRECTED: Import the new component
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Skeleton } from "@/components/ui/skeleton"

export default function Dashboard() {
  const [isOffline, setIsOffline] = useState(false)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Simulate initial dashboard loading
    const timer = setTimeout(() => setLoading(false), 500)

    // Online/Offline listeners
    const handleOnline = () => setIsOffline(false)
    const handleOffline = () => setIsOffline(true)
    
    if (typeof window !== 'undefined') {
        setIsOffline(!navigator.onLine);
        window.addEventListener("online", handleOnline)
        window.addEventListener("offline", handleOffline)
    }

    return () => {
      clearTimeout(timer)
      if (typeof window !== 'undefined') {
        window.removeEventListener("online", handleOnline)Â 
        window.removeEventListener("offline", handleOffline)
      }
    }
  }, [])

  return (
    <div className="min-h-screen flex flex-col bg-gray-50">
      <LiveOrderNotification />
      {isOffline && (
        <motion.div
          className="bg-red-500 text-white text-center py-2 font-medium"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          âš ï¸ You are offline. Some features may not be available.
        </motion.div>
      )}

      <div className="flex-1 px-4 sm:px-6 lg:px-8 py-6">
        <div className="max-w-7xl mx-auto space-y-8">
          <div className="flex flex-col lg:flex-row gap-8">
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.5 }}
            >
              <DashboardNavCards />
            </motion.div>

            <div className="flex-1">
              <motion.div
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5, delay: 0.1 }}
              >
                <Card className="shadow-md">
                  <CardHeader>
                    <CardTitle className="text-xl font-bold text-slate-800">Recent Activity</CardTitle>
                  </CardHeader>
                  <CardContent>
                    {loading ? (
                        <div className="space-y-4">
                            <Skeleton className="h-16 w-full" />
                            <Skeleton className="h-16 w-full" />
                            <Skeleton className="h-16 w-full" />
                        </div>
                    ) : (
                        <RecentOrders />
                    )}
                  </CardContent>
                </Card>
              </motion.div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\dashboard\providers.tsx -----

"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        {children}
        <Toaster />
        <Sonner />
      </TooltipProvider>
    </QueryClientProvider>
  );
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\login\page.tsx -----

'use client'
import { useState, useEffect } from 'react'
import { loginWithEmail } from '@/lib/auth/login'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import dynamic from 'next/dynamic'
import { motion } from 'framer-motion'

// Lazy load icon
const Loader2 = dynamic(() => import('lucide-react').then(m => m.Loader2))

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [isOffline, setIsOffline] = useState(false)
  const router = useRouter()

  useEffect(() => {
    const handleOnline = () => setIsOffline(false)
    const handleOffline = () => setIsOffline(true)

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    setIsOffline(!navigator.onLine)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    if (isOffline) return

    setError(null)
    setIsSubmitting(true)

    const { error } = await loginWithEmail(email, password)
    if (error) {
      setError(error.message)
      setIsSubmitting(false)
    } else {
      router.push('/dashboard')
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-blue-100 p-4 sm:p-8 flex items-center justify-center">
      <motion.div
        className="max-w-md w-full"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
      >
        <div className="bg-white rounded-2xl shadow-md p-8">
          <h1 className="text-3xl font-bold text-gray-800 text-center">Welcome Back!</h1>
          <p className="text-gray-600 mt-2 text-center">Log in to manage your restaurant.</p>

          {isOffline && (
            <p className="mt-3 text-center text-sm text-red-600 font-medium bg-red-100 p-2 rounded-lg">
              Youâ€™re offline. Please reconnect to continue.
            </p>
          )}

          <form onSubmit={handleLogin} className="mt-8 space-y-6">
            <input
              className="w-full p-3 border-2 rounded-lg text-gray-900"
              placeholder="Email"
              type="email"
              value={email}
              onChange={e => setEmail(e.target.value)}
              required
              disabled={isOffline}
            />

            <input
              className="w-full p-3 border-2 rounded-lg text-gray-900"
              placeholder="Password"
              type="password"
              value={password}
              onChange={e => setPassword(e.target.value)}
              required
              disabled={isOffline}
            />

            {error && (
              <motion.p
                className="text-red-500 text-center"
                initial={{ opacity: 0, y: -5 }}
                animate={{ opacity: 1, y: 0 }}
              >
                {error}
              </motion.p>
            )}

            <button
              type="submit"
              disabled={isSubmitting || isOffline}
              className="w-full bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold p-3 rounded-lg flex items-center justify-center disabled:opacity-50"
            >
              {isSubmitting && <Loader2 className="mr-2 h-5 w-5 animate-spin" />}
              {isSubmitting ? 'Logging In...' : 'Log In'}
            </button>

            <p className="text-center text-gray-600">
              Don&apos;t have an account?{' '}
              <Link href="/signup" className="font-semibold text-indigo-600 hover:underline">
                Sign Up
              </Link>
            </p>
          </form>
        </div>
      </motion.div>
    </div>
  )
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\offline\page.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { Wifi, WifiOff, RefreshCw, Home } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

export default function OfflinePage() {
  const [isOnline, setIsOnline] = useState(false);
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    const checkOnlineStatus = () => {
      setIsOnline(navigator.onLine);
    };

    // Check initial status
    checkOnlineStatus();

    // Listen for online/offline events
    window.addEventListener('online', checkOnlineStatus);
    window.addEventListener('offline', checkOnlineStatus);

    return () => {
      window.removeEventListener('online', checkOnlineStatus);
      window.removeEventListener('offline', checkOnlineStatus);
    };
  }, []);

  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
    window.location.reload();
  };

  const handleGoHome = () => {
    window.location.href = '/';
  };

  if (isOnline) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <Card className="w-full max-w-md">
          <CardHeader className="text-center">
            <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-green-100">
              <Wifi className="h-6 w-6 text-green-600" />
            </div>
            <CardTitle className="text-xl">You&apos;re Back Online!</CardTitle>
            <CardDescription>
              Your connection has been restored. You can now continue using the app.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button onClick={handleRetry} className="w-full">
              <RefreshCw className="mr-2 h-4 w-4" />
              Refresh Page
            </Button>
            <Button onClick={handleGoHome} variant="outline" className="w-full">
              <Home className="mr-2 h-4 w-4" />
              Go to Home
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-red-100">
            <WifiOff className="h-6 w-6 text-red-600" />
          </div>
          <CardTitle className="text-xl">You&apos;re Offline</CardTitle>
          <CardDescription>
            It looks like you&apos;ve lost your internet connection. Some features may not be available.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="text-sm text-gray-600 space-y-2">
            <p>â€¢ Check your internet connection</p>
            <p>â€¢ Try refreshing the page</p>
            <p>â€¢ Some cached content may still be available</p>
          </div>
          
          <div className="space-y-2">
            <Button onClick={handleRetry} className="w-full">
              <RefreshCw className="mr-2 h-4 w-4" />
              Try Again
            </Button>
            <Button onClick={handleGoHome} variant="outline" className="w-full">
              <Home className="mr-2 h-4 w-4" />
              Go to Home
            </Button>
          </div>

          {retryCount > 0 && (
            <p className="text-xs text-gray-500 text-center">
              Retry attempts: {retryCount}
            </p>
          )}
        </CardContent>
      </Card>
    </div>
  );
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\signup\page.tsx -----

'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { signUpWithRestaurant, SignUpData } from '@/lib/auth/signup';
import dynamic from 'next/dynamic';
import { motion } from 'framer-motion';

// Lazy load loader icon
const Loader2 = dynamic(() => import('lucide-react').then(m => m.Loader2));

export default function SignUpPage() {
  const [formData, setFormData] = useState<SignUpData>({
    email: '',
    password: '',
    owner_name: '',
    restaurant_name: '',
    phone: '',
    address: '',
    upi_id: '',
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [isOffline, setIsOffline] = useState(false);

  // Detect offline/online
  useEffect(() => {
    const handleOnline = () => setIsOffline(false);
    const handleOffline = () => setIsOffline(true);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    setIsOffline(!navigator.onLine);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isOffline) return;

    setError(null);
    setIsSubmitting(true);

    try {
      await signUpWithRestaurant(formData);
      setSuccess(true);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 to-blue-100 p-4 sm:p-8 flex items-center justify-center">
      <motion.div
        className="max-w-2xl w-full"
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
      >
        <div className="bg-white rounded-2xl shadow-md p-8">
          <h1 className="text-3xl font-bold text-gray-800 text-center">Create Your Account</h1>
          <p className="text-gray-600 mt-2 text-center">
            Set up your restaurant profile to get started.
          </p>

          {isOffline && (
            <p className="mt-3 text-center text-sm text-red-600 font-medium bg-red-100 p-2 rounded-lg">
              Youâ€™re offline. Please reconnect to continue.
            </p>
          )}

          {success ? (
            <motion.div
              className="text-center py-12"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ duration: 0.5 }}
            >
              <h2 className="text-2xl font-semibold text-green-600">
                Registration Successful!
              </h2>
              <p className="mt-2 text-gray-700">
                Please check your email to confirm your account before logging in.
              </p>
              <Link
                href="/login"
                className="mt-6 inline-block bg-indigo-600 text-white font-semibold px-6 py-3 rounded-lg"
              >
                Go to Login
              </Link>
            </motion.div>
          ) : (
            <form onSubmit={handleSubmit} className="mt-8 space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <input name="owner_name" type="text" placeholder="Owner's Name" value={formData.owner_name} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
                <input name="restaurant_name" type="text" placeholder="Restaurant Name" value={formData.restaurant_name} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
                <input name="email" type="email" placeholder="Email Address" value={formData.email} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
                <input name="password" type="password" placeholder="Password" value={formData.password} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
                <input name="phone" type="tel" placeholder="Phone Number" value={formData.phone} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
                <input name="address" type="text" placeholder="Address" value={formData.address} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
              </div>
              <input name="upi_id" type="text" placeholder="UPI ID (for payments)" value={formData.upi_id} onChange={handleChange} required className="w-full p-3 border-2 rounded-lg text-gray-900" disabled={isOffline}/>
              
              {error && (
                <motion.p
                  className="text-red-500 text-center"
                  initial={{ opacity: 0, y: -5 }}
                  animate={{ opacity: 1, y: 0 }}
                >
                  {error}
                </motion.p>
              )}

              <button
                type="submit"
                disabled={isSubmitting || isOffline}
                className="w-full bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold p-3 rounded-lg flex items-center justify-center disabled:opacity-50"
              >
                {isSubmitting && <Loader2 className="mr-2 h-5 w-5 animate-spin" />}
                {isSubmitting ? 'Registering...' : 'Create Account'}
              </button>

              <p className="text-center text-gray-600">
                Already have an account?{' '}
                <Link href="/login" className="font-semibold text-indigo-600 hover:underline">
                  Log In
                </Link>
              </p>
            </form>
          )}
        </div>
      </motion.div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\simple-test\page.tsx -----

export default function SimpleTestPage() {
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">Simple Test Page</h1>
      <p>This is a simple test page to check if Next.js is working.</p>
      <div className="mt-4 p-4 bg-blue-100 rounded">
        <p>If you can see this, the basic setup is working!</p>
      </div>
    </div>
  );
}


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\test\page.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase/client';

export default function TestPage() {
  const [orders, setOrders] = useState<any[]>([]);
  const [restaurants, setRestaurants] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchOrders() {
      try {
        setLoading(true);
        
        // Test 1: Get all orders
        const { data: allOrders, error: allError } = await supabase
          .from('orders')
          .select('*')
          .limit(10);

        if (allError) {
          setError(`Error fetching all orders: ${allError.message}`);
          return;
        }

        console.log('All orders:', allOrders);
        setOrders(allOrders || []);

        // Test 2: Get specific order by track_code
        const { data: specificOrder, error: specificError } = await supabase
          .from('orders')
          .select(`
            id, track_code, status, estimated_time, created_at,
            restaurant:restaurants (restaurant_name, slug),
            table:tables (table_number)
          `)
          .eq('track_code', 'upmi0jl0');

        if (specificError) {
          console.error('Error fetching specific order:', specificError);
        } else {
          console.log('Specific order for upmi0jl0:', specificOrder);
        }

        // Test 3: Get all restaurants
        const { data: restaurants, error: restaurantsError } = await supabase
          .from('restaurants')
          .select('id, restaurant_name, slug');

        if (restaurantsError) {
          console.error('Error fetching restaurants:', restaurantsError);
        } else {
          console.log('All restaurants:', restaurants);
          setRestaurants(restaurants || []);
        }

      } catch (err) {
        setError(`Unexpected error: ${err}`);
      } finally {
        setLoading(false);
      }
    }

    fetchOrders();
  }, []);

  if (loading) {
    return <div className="p-6">Loading...</div>;
  }

  if (error) {
    return <div className="p-6 text-red-600">Error: {error}</div>;
  }

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Database Test</h1>
      
      <h2 className="text-xl font-semibold mb-2">Recent Orders:</h2>
      <div className="space-y-2">
        {orders.map((order) => (
          <div key={order.id} className="border p-3 rounded">
            <p><strong>ID:</strong> {order.id}</p>
            <p><strong>Track Code:</strong> {order.track_code}</p>
            <p><strong>Status:</strong> {order.status}</p>
            <p><strong>Restaurant ID:</strong> {order.restaurant_id}</p>
            <p><strong>Created:</strong> {new Date(order.created_at).toLocaleString()}</p>
          </div>
        ))}
      </div>

      <h2 className="text-xl font-semibold mb-2 mt-6">Restaurants:</h2>
      <div className="space-y-2">
        {restaurants.map((restaurant) => (
          <div key={restaurant.id} className="border p-3 rounded">
            <p><strong>ID:</strong> {restaurant.id}</p>
            <p><strong>Name:</strong> {restaurant.restaurant_name}</p>
            <p><strong>Slug:</strong> {restaurant.slug}</p>
          </div>
        ))}
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\layout.tsx -----

// src/app/layout.tsx
import type { Metadata, Viewport } from "next";
import { Inter } from 'next/font/google';
import "./globals.css";

import AuthListener from "@/components/AuthListener";
import OfflineIndicator from "@/components/OfflineIndicator";
import ServiceWorkerRegistration from "@/components/ServiceWorkerRegistration";
import OfflineStatusBar from "@/components/OfflineStatusBar";

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
Â  title: "Quick Bite QR - Restaurant Management",
Â  description: "Restaurant management and QR code generation app with offline support",
Â  manifest: "/manifest.json",
Â  appleWebApp: {
Â  Â  capable: true,
Â  Â  statusBarStyle: "default",
Â  Â  title: "Quick Bite QR",
Â  },
Â  formatDetection: {
Â  Â  telephone: false,
Â  },
};

// Fix for metadata warnings
export const viewport: Viewport = {
  themeColor: "#000000",
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
};

export default function RootLayout({
Â  children,
}: Readonly<{
Â  children: React.ReactNode;
}>) {
Â  return (
Â  Â  <html lang="en">
Â  Â  Â  <body className={inter.className}>
Â  Â  Â  Â  <AuthListener />
Â  Â  Â  Â  <OfflineIndicator />
Â  Â  Â  Â  <ServiceWorkerRegistration />
Â  Â  Â  Â  {children}
Â  Â  Â  Â  <OfflineStatusBar />
Â  Â  Â  </body>
Â  Â  </html>
Â  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\middleware.ts -----

// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  await supabase.auth.getSession();
  return res;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\app\page.tsx -----

export default function Home() {
  return (
    <h1>QuickBiteQR</h1>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\menu\DeleteConfirmation.tsx -----

// src/components/menu/DeleteConfirmation.tsx
interface DeleteConfirmationProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  itemName: string;
}

export default function DeleteConfirmation({
  isOpen,
  onClose,
  onConfirm,
  itemName
}: DeleteConfirmationProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-2xl p-6 max-w-md w-full">
        <div className="text-center mb-4">
          <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-red-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
          </div>
        </div>
        <h3 className="text-lg font-semibold text-gray-800 text-center mb-2">Confirm Deletion</h3>
        <p className="text-gray-600 text-center mb-6">
          Are you sure you want to delete &quot;{itemName}&quot;? This action cannot be undone.
        </p>
        <div className="flex justify-center space-x-4">
          <button
            onClick={onClose}
            className="px-5 py-2 border border-gray-300 rounded-xl text-gray-700 hover:bg-gray-100 transition-colors"
          >
            Cancel
          </button>
          <button
            onClick={onConfirm}
            className="px-5 py-2 bg-red-600 text-white rounded-xl hover:bg-red-700 transition-colors"
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\menu\ImageUpload.tsx -----

'use client';

import { useState, useCallback } from 'react';
import Image from "next/image";
import { useDropzone } from "react-dropzone";
import { useUploadThing } from "@/lib/uploadthing";
import { compressImage } from '@/lib/utils/image-compressor'; // 1. Import the new function
import { X, UploadCloud, Loader2, AlertTriangle } from "lucide-react";

interface ImageUploadProps {
  onChange: (url?: string) => void;
  value?: string;
}

export default function ImageUpload({ onChange, value }: ImageUploadProps) {
  const [preview, setPreview] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadError, setUploadError] = useState<string | null>(null);

  const { startUpload } = useUploadThing(
    "menuItemImage",
    {
      onClientUploadComplete: (res:{url:string}[]) => {
        setIsUploading(false);
        setUploadError(null);
        onChange(res?.[0].url);
        setPreview(null);
      },
      onUploadError: (error: Error) => {
        setIsUploading(false);
        setPreview(null);
        setUploadError("Upload failed. Please try again.");
        console.error("Upload failed:", error);
      },
    }
  );

  // 2. Simplify the onDrop handler
  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    setUploadError(null);
    if (acceptedFiles.length > 0) {
      const file = acceptedFiles[0];
      
      setPreview(URL.createObjectURL(file));
      setIsUploading(true);

      try {
        // Use the utility function to compress the image
        const compressedFile = await compressImage(file);
        
        // Upload the compressed file
        await startUpload([compressedFile]);

      } catch (error: any) {
        setUploadError(error.message || 'Compression failed.');
        setIsUploading(false);
        setPreview(null);
      }
    }
  }, [startUpload]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { 'image/*': ['.jpeg', '.jpg', '.png'] },
    multiple: false,
  });

  // The rest of the component's JSX remains unchanged...
  if (value) {
    return (
      <div className="relative h-48 w-full md:w-96">
        <Image
          fill
          src={value}
          alt="Uploaded Image"
          className="rounded-lg object-cover"
        />
        <button
          onClick={() => onChange()}
          className="bg-red-500 text-white p-1 rounded-full absolute -top-2 -right-2 shadow-sm"
          type="button"
        >
          <X className="h-4 w-4" />
        </button>
      </div>
    );
  }

  if (isUploading || preview) {
    return (
      <div className="relative h-48 w-full md:w-96">
        {preview && (
          <Image
            fill
            src={preview}
            alt="Image Preview"
            className="rounded-lg object-cover"
            onLoad={() => {
              if (preview) URL.revokeObjectURL(preview);
            }}
          />
        )}
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center rounded-lg">
          <Loader2 className="h-8 w-8 text-white animate-spin" />
        </div>
      </div>
    );
  }

  return (
    <div
      {...getRootProps()}
      className={`
        w-full md:w-96 h-48 border-2 border-dashed rounded-lg flex items-center justify-center text-center cursor-pointer
        ${isDragActive ? 'border-indigo-600 bg-indigo-50' : 'border-gray-300'}
        ${uploadError ? 'border-red-500 bg-red-50' : ''}
      `}
    >
      <input {...getInputProps()} />
      <div className="text-gray-500">
        {uploadError ? (
          <div className="text-red-600">
            <AlertTriangle className="h-8 w-8 mx-auto mb-2" />
            <p className="text-sm font-semibold">{uploadError}</p>
          </div>
        ) : (
          <>
            <UploadCloud className="h-8 w-8 mx-auto mb-2" />
            <p className="text-sm">{isDragActive ? 'Drop the image here' : 'Click or drag to upload'}</p>
          </>
        )}
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\menu\MenuItemCard.tsx -----

import Image from 'next/image';
import Link from 'next/link';
import { MenuItem } from '@/types/menu'; // Ensure this path is correct

interface MenuItemCardProps {
  item: MenuItem;
  onEdit: string;
  onDelete: () => void;
}

// Helper to format price
const formatPrice = (price: number) => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(price);
};

export default function MenuItemCard({ item, onEdit, onDelete }: MenuItemCardProps) {
  return (
    <div className="bg-white rounded-2xl shadow-md overflow-hidden transition-all hover:shadow-xl hover:-translate-y-1 flex flex-col">
      {/* Image Section */}
      <div className="relative h-40 w-full bg-gray-100">
        {item.photo_url ? (
          <Image
            src={item.photo_url}
            alt={item.name}
            layout="fill"
            objectFit="cover"
            className="transition-transform duration-300 group-hover:scale-105"
          />
        ) : (
          // Placeholder for items without an image
          <div className="flex items-center justify-center h-full">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
          </div>
        )}
      </div>

      {/* Content Section */}
      <div className="p-4 flex-grow">
        <h3 className="text-lg font-bold text-gray-800 truncate">{item.name}</h3>
        <p className="text-sm text-gray-600 mt-1 h-10 overflow-hidden">{item.description}</p>
        <p className="text-xl font-bold text-indigo-600 mt-3">{formatPrice(item.price)}</p>
      </div>

      {/* Actions Section */}
      <div className="p-3 bg-gray-50 border-t flex justify-end gap-2">
        <Link href={onEdit} className="px-4 py-1.5 rounded-md text-sm font-semibold text-gray-700 bg-white border border-gray-300 hover:bg-gray-100 transition-colors">
          Edit
        </Link>
        <button
          onClick={onDelete}
          className="px-4 py-1.5 rounded-md text-sm font-semibold text-white bg-red-500 hover:bg-red-600 transition-colors"
        >
          Delete
        </button>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\menu\MenuItemForm.tsx -----

'use client';

import { useState, useEffect } from 'react';
import { MenuItem } from '@/types/menu';
import ImageUpload from './ImageUpload';

interface MenuItemFormProps {
  initialData?: MenuItem;
  onSubmit: (data: Omit<MenuItem, 'id' | 'restaurant_id' | 'created_at'>) => void;
  isSubmitting: boolean;
  onCancel: () => void;
}

export default function MenuItemForm({
  initialData,
  onSubmit,
  isSubmitting,
  onCancel
}: MenuItemFormProps) {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    price: '',
    photo_url: '',
    available: true,
  });

  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  useEffect(() => {
    if (initialData) {
      setFormData({
        name: initialData.name,
        description: initialData.description,
        price: String(initialData.price),
        photo_url: initialData.photo_url || '',
        available: initialData.available ?? true,
      });
    }
  }, [initialData]);
  
  const validate = () => {
    const newErrors: { [key: string]: string } = {};
    if (!formData.name.trim()) newErrors.name = 'Name is required.';
    if (!formData.description.trim()) newErrors.description = 'Description is required.';
    if (!formData.price) newErrors.price = 'Price is required.';
    const priceValue = parseFloat(formData.price);
    if (isNaN(priceValue) || priceValue <= 0) {
      newErrors.price = 'Please enter a valid, positive price.';
    }
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    
    if (type === 'checkbox') {
      const { checked } = e.target as HTMLInputElement;
      setFormData(prev => ({ ...prev, [name]: checked }));
      return;
    }
    
    if (name === 'price') {
      const numericValue = value.replace(/[^0-9.]/g, '');
      const decimalCount = (numericValue.match(/\./g) || []).length;
      const sanitizedValue = decimalCount > 1 ? numericValue.substring(0, numericValue.lastIndexOf('.')) : numericValue;
      setFormData(prev => ({ ...prev, [name]: sanitizedValue }));
      return;
    }
    
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (validate()) {
      onSubmit({
        ...formData,
        price: parseFloat(formData.price),
      });
    }
  };

  return (
    <div className="bg-white rounded-2xl shadow-md overflow-hidden">
      <form onSubmit={handleSubmit} className="p-6 md:p-8 space-y-6">
        {/* Image Upload */}
        <div className="flex flex-col items-center">
          <label className="w-full text-lg font-semibold text-gray-800 mb-2">Item Image</label>
          <ImageUpload
            value={formData.photo_url}
            onChange={(url) => setFormData(prev => ({ ...prev, photo_url: url || '' }))}
          />
        </div>
        
        {/* Name */}
        <div>
          <label htmlFor="name" className="block text-lg font-semibold text-gray-800 mb-2">Name *</label>
          <input
            type="text"
            id="name"
            name="name"
            value={formData.name}
            onChange={handleChange}
            className="w-full p-3 border-2 border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 text-gray-900 transition-all"
          />
          {errors.name && <p className="text-red-500 text-sm mt-1">{errors.name}</p>}
        </div>

        {/* Description */}
        <div>
          <label htmlFor="description" className="block text-lg font-semibold text-gray-800 mb-2">Description *</label>
          <textarea
            id="description"
            name="description"
            value={formData.description}
            onChange={handleChange}
            rows={4}
            className="w-full p-3 border-2 border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 text-gray-900 transition-all"
          />
          {errors.description && <p className="text-red-500 text-sm mt-1">{errors.description}</p>}
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Price */}
          <div>
            <label htmlFor="price" className="block text-lg font-semibold text-gray-800 mb-2">Price ($) *</label>
            <input
              type="text"
              id="price"
              name="price"
              value={formData.price}
              onChange={handleChange}
              className="w-full p-3 border-2 border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 text-gray-900 transition-all"
              placeholder="0.00"
              inputMode="decimal"
            />
            {errors.price && <p className="text-red-500 text-sm mt-1">{errors.price}</p>}
          </div>
        </div>
            
        {/* Available Toggle */}
        <div className="flex items-center justify-between bg-gray-50 p-4 rounded-xl border-2 border-gray-200">
          <label htmlFor="available" className="text-lg font-semibold text-gray-800">Item Available</label>
          <label className="relative inline-flex items-center cursor-pointer">
            <input
              type="checkbox"
              id="available"
              name="available"
              checked={formData.available}
              onChange={handleChange}
              className="sr-only peer"
            />
            <div className="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-indigo-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
          </label>
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end space-x-4 pt-6 border-t border-gray-200">
          <button
            type="button"
            onClick={onCancel}
            className="px-6 py-3 border-2 border-gray-300 rounded-xl font-semibold text-gray-700 hover:bg-gray-100 transition-all"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={isSubmitting}
            className="px-6 py-3 bg-gradient-to-r from-indigo-500 to-blue-500 text-white font-semibold rounded-xl hover:from-indigo-600 hover:to-blue-600 disabled:opacity-50 transition-all shadow-md hover:shadow-lg"
          >
            {isSubmitting ? 'Saving...' : 'Save Item'}
          </button>
        </div>
      </form>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\orders\ETA.tsx -----

'use client';

import React, { useMemo } from 'react';
import type { CustomerOrderStatus } from './OrderStatusTimeline';

export default function ETA({
  currentStatus,
  etaMinutes,
}: {
  currentStatus: CustomerOrderStatus;
  etaMinutes?: number | null; // This type accepts number, null, or undefined
}) {
  const derivedMinutes = useMemo(() => {
    // This check correctly handles both null and undefined values.
    if (typeof etaMinutes === 'number') return etaMinutes;
    
    // Simple fallback heuristics
    if (currentStatus === 'Pending') return 20;
    if (currentStatus === 'Confirmed') return 18;
    if (currentStatus === 'Preparing') return 10;
    if (currentStatus === 'Ready') return 2;
    return 0;
  }, [etaMinutes, currentStatus]);

  if (currentStatus === 'Complete' || currentStatus === 'Cancelled') {
    return (
      <p className="text-lg font-semibold text-gray-500">
        N/A
      </p>
    );
  }

  return (
    <p className="text-lg font-semibold text-gray-900">
      ~ {derivedMinutes} min
    </p>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\orders\OrderStatusTimeline.tsx -----

'use client';

import React from 'react';
import { CheckCircle2, Circle } from 'lucide-react';

export type CustomerOrderStatus = 'Pending' | 'Confirmed' | 'Preparing' | 'Ready' | 'Complete' | 'Cancelled';

const STEPS: { key: CustomerOrderStatus; label: string }[] = [
  { key: 'Pending',   label: 'Payment confirmation' },
  { key: 'Confirmed', label: 'Order received' },
  { key: 'Preparing', label: 'Being cooked' },
  { key: 'Ready',     label: 'Ready to serve' },
  { key: 'Complete',  label: 'Completed' },
];

function indexOfStatus(s: CustomerOrderStatus) {
  const i = STEPS.findIndex((x) => x.key === s);
  return i < 0 ? 0 : i;
}

export default function OrderStatusTimeline({ currentStatus }: { currentStatus: CustomerOrderStatus }) {
  const currentIdx = indexOfStatus(currentStatus);

  return (
    <div className="bg-white rounded-xl shadow p-5">
      <ol className="relative border-s-2 border-gray-200 ps-6">
        {STEPS.map((step, idx) => {
          const done = idx <= currentIdx && currentStatus !== 'Cancelled';
          const active = idx === currentIdx;

          return (
            <li key={step.key} className="mb-8 ms-6">
              <span className="absolute -start-3 flex h-6 w-6 items-center justify-center rounded-full bg-white">
                {done ? <CheckCircle2 className="h-6 w-6" /> : <Circle className="h-6 w-6" />}
              </span>
              <h3 className={`font-semibold ${active ? 'text-gray-900' : 'text-gray-700'}`}>{step.label}</h3>
              <p className="mt-1 text-sm text-gray-500">{step.key}</p>
            </li>
          );
        })}
        {currentStatus === 'Cancelled' && (
          <li className="mb-2 ms-6">
            <span className="absolute -start-3 h-6 w-6 rounded-full bg-white" />
            <h3 className="font-semibold text-red-600">Order Cancelled</h3>
            <p className="mt-1 text-sm text-gray-500">Please contact staff if this seems incorrect.</p>
          </li>
        )}
      </ol>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\orders\StatusBadge.tsx -----

'use client';

import React from 'react';
import type { CustomerOrderStatus } from './OrderStatusTimeline';

export default function StatusBadge({ status }: { status: CustomerOrderStatus }) {
  const color =
    status === 'Pending' ? 'bg-yellow-100 text-yellow-800' :
    status === 'Confirmed' ? 'bg-blue-100 text-blue-800' :
    status === 'Preparing' ? 'bg-orange-100 text-orange-800' :
    status === 'Ready' ? 'bg-green-100 text-green-800' :
    status === 'Complete' ? 'bg-emerald-100 text-emerald-800' :
    'bg-red-100 text-red-700';

  return (
    <span className={`inline-flex items-center px-3 py-1 text-sm font-medium rounded-full ${color}`}>
      {status}
    </span>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\tables\QrCodeDisplay.tsx -----

'use client';

import Image from 'next/image'; // Use the Next.js Image component

interface QrCodeDisplayProps {
  url: string;
  tableName: string;
}

export default function QrCodeDisplay({ url, tableName }: QrCodeDisplayProps) {
  // This function now simply creates a link to the image URL for downloading
  const downloadQRCode = () => {
    const link = document.createElement('a');
    link.href = url;
    // Add the 'download' attribute to prompt a download
    link.setAttribute('download', `${tableName.replace(/\s+/g, '-')}-qr-code.png`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="flex flex-col items-center gap-4 p-4 border rounded-lg bg-gray-50">
      {/* Display the QR code using a standard Image component */}
      <div className="relative h-32 w-32">
        <Image 
          src={url} 
          alt={`QR Code for ${tableName}`} 
          layout="fill" 
          objectFit="contain" 
        />
      </div>
      <button
        onClick={downloadQRCode}
        className="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 w-full font-semibold transition-colors"
      >
        Download
      </button>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\alert.tsx -----

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\avatar.tsx -----

"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\badge.tsx -----

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\button.tsx -----

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\calendar.tsx -----

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: () => <ChevronLeft className="h-4 w-4" />,
        IconRight: () => <ChevronRight className="h-4 w-4" />,
      } as any}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\card.tsx -----

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\input.tsx -----

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\label.tsx -----

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\popover.tsx -----

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\separator.tsx -----

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\skeleton.tsx -----

import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\sonner.tsx -----

import { useTheme } from "next-themes"
import { Toaster as Sonner, toast } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster, toast }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\tabs.tsx -----

"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\textarea.tsx -----

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\toast.tsx -----

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\toaster.tsx -----

import { useToast } from "@/lib/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ui\tooltip.tsx -----

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\AuthListener.tsx -----

'use client'
import { useEffect } from 'react'
import { supabase }  from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'

export default function AuthListener() {
  const router = useRouter()

  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange((event) => {
      console.log('Auth event:', event)

      if (event === 'SIGNED_IN') {
        router.push('/dashboard') // or wherever you want
      }

      if (event === 'SIGNED_OUT') {
        router.push('/login')
      }

      // You can also handle TOKEN_REFRESHED, USER_UPDATED, etc.
    })

    return () => {
      authListener?.subscription.unsubscribe()
    }
  }, [])

  return null
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\DashboardNavCards.tsx -----

"use client";

import Link from "next/link";
import { Utensils, Clock, List, Table as TableIcon } from "lucide-react";

export function DashboardNavCards() {
  return (
    <div className="w-64 bg-white/90 backdrop-blur-md rounded-2xl border border-gray-200 shadow-lg p-4 flex flex-col gap-4">
      {/* Tables */}
      <Link
        href="/dashboard/tables"
        className="group relative flex items-center gap-4 overflow-hidden bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl border border-blue-100 shadow hover:shadow-lg transition-all duration-300 p-4"
      >
        <div className="p-3 rounded-lg bg-gradient-to-br from-blue-600 to-blue-500 text-white shadow-md">
          <TableIcon className="w-5 h-5" />
        </div>
        <div>
          <div className="text-slate-800 font-semibold text-base">Tables</div>
          <div className="text-slate-600 text-xs">Seating & turnover</div>
        </div>
      </Link>

      {/* Menus */}
      <Link
        href="/dashboard/menus"
        className="group relative flex items-center gap-4 overflow-hidden bg-gradient-to-br from-purple-50 to-purple-100 rounded-xl border border-purple-100 shadow hover:shadow-lg transition-all duration-300 p-4"
      >
        <div className="p-3 rounded-lg bg-gradient-to-br from-purple-600 to-purple-500 text-white shadow-md">
          <Utensils className="w-5 h-5" />
        </div>
        <div>
          <div className="text-slate-800 font-semibold text-base">Menus</div>
          <div className="text-slate-600 text-xs">Collections & sets</div>
        </div>
      </Link>

      {/* Menu Items */}
      <Link
        href="/dashboard/menu_items"
        className="group relative flex items-center gap-4 overflow-hidden bg-gradient-to-br from-emerald-50 to-emerald-100 rounded-xl border border-emerald-100 shadow hover:shadow-lg transition-all duration-300 p-4"
      >
        <div className="p-3 rounded-lg bg-gradient-to-br from-emerald-600 to-emerald-500 text-white shadow-md">
          <List className="w-5 h-5" />
        </div>
        <div>
          <div className="text-slate-800 font-semibold text-base">Menu Items</div>
          <div className="text-slate-600 text-xs">Dishes & prices</div>
        </div>
      </Link>

      {/* Order History */}
      <Link
        href="/dashboard/orders"
        className="group relative flex items-center gap-4 overflow-hidden bg-gradient-to-br from-slate-50 to-slate-100 rounded-xl border border-slate-200 shadow hover:shadow-lg transition-all duration-300 p-4"
      >
        <div className="p-3 rounded-lg bg-gradient-to-br from-slate-800 to-slate-700 text-white shadow-md">
          <Clock className="w-5 h-5" />
        </div>
        <div>
          <div className="text-slate-800 font-semibold text-base">Order History</div>
          <div className="text-slate-600 text-xs">Past orders</div>
        </div>
      </Link>
    </div>
  );
}


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\FormattedDate.tsx -----

'use client';

import { useState, useEffect } from 'react';

type FormattedDateProps = {
  dateString: string;
};

export default function FormattedDate({ dateString }: FormattedDateProps) {
  // State to track if the component has mounted on the client
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    // This effect runs only on the client, after the initial render
    setIsMounted(true);
  }, []);

  // On the server, and during the first client render before the effect runs,
  // we return null or a placeholder to avoid a mismatch.
  if (!isMounted) {
    return null; // Or <Skeleton className="h-5 w-32" />
  }

  // Once mounted, we can safely use the browser's `toLocaleString`
  return <>{new Date(dateString).toLocaleString()}</>;
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\LiveOrderNotification.tsx -----


"use client";

import { useState, useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Bell, X, Clock, CheckCircle, AlertCircle } from "lucide-react";
import { supabase } from "@/lib/supabase/client";

interface Notification {
  id: number;
  user_id: string | null;
  order_id: string | null;
  type: "new_order" | "order_ready" | "order_delayed";
  message: string;
  is_read: boolean;
  created_at: string; // ISO timestamp
}

export function LiveOrderNotification() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isVisible, setIsVisible] = useState(false);
  const [notificationCount, setNotificationCount] = useState(0);

  // Fetch latest notifications
  const fetchNotifications = async () => {
    const { data, error } = await supabase
      .from("notifications")
      .select("*")
      .order("created_at", { ascending: false })
      .limit(5);
      console.log("Fetched notifications:", data, error);

    if (error) {
      console.error("Error fetching notifications:", error);
    } else {
      setNotifications(data || []);
      setNotificationCount(data?.length || 0);
    }
  };

  // Dismiss a single notification
  const dismissNotification = (id: number) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
    setNotificationCount((prev) => Math.max(0, prev - 1));

    // Optionally mark it as read in DB
    supabase.from("notifications").update({ is_read: true }).eq("id", id);
  };

  // Dismiss all notifications
  const dismissAll = () => {
    setNotifications([]);
    setNotificationCount(0);

    // Optionally mark all as read
    supabase.from("notifications").update({ is_read: true }).eq("is_read", false);
  };

  useEffect(() => {
    fetchNotifications();

    // Subscribe to new notifications in real-time
    const channel = supabase
      .channel("live-notifications")
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "notifications" },
        (payload) => {
          const newNotification = payload.new as Notification;
          setNotifications((prev) => [newNotification, ...prev].slice(0, 5));
          setNotificationCount((prev) => prev + 1);

          // Show panel temporarily
          setIsVisible(true);
          setTimeout(() => setIsVisible(false), 4500);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  if (notifications.length === 0) return null;

  return (
    <div
      className={`fixed top-4 right-4 z-50 w-80 bg-white/95 backdrop-blur-sm border border-gray-200 rounded-lg shadow-impressive transition-opacity duration-300 ${
        isVisible ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}
    >
      {/* Header */}
      <div className="bg-gradient-to-r from-blue-600 to-purple-600 text-white p-3 rounded-t-lg flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Bell className="w-4 h-4 animate-pulse-slow" />
          <span className="font-semibold text-sm">Live Orders</span>
          {notificationCount > 0 && (
            <Badge
              variant="secondary"
              className="bg-white/20 text-white border-white/30 animate-bounce-in"
            >
              {notificationCount}
            </Badge>
          )}
        </div>
        <Button
          variant="ghost"
          size="sm"
          onClick={dismissAll}
          className="h-6 w-6 p-0 text-white hover:bg-white/20"
        >
          <X className="w-3 h-3" />
        </Button>
      </div>

      {/* Notifications List */}
      <div className="max-h-64 overflow-y-auto">
        {notifications.map((notification) => (
          <div
            key={notification.id}
            className={`p-3 border-b border-gray-100 last:border-b-0 ${
              !notification.is_read ? "bg-blue-50/50 animate-glow" : ""
            }`}
          >
            <div className="flex items-start justify-between gap-2">
              <div className="flex items-start gap-2 flex-1">
                {notification.type === "new_order" && (
                  <Bell className="w-4 h-4 text-blue-600 mt-0.5" />
                )}
                {notification.type === "order_ready" && (
                  <CheckCircle className="w-4 h-4 text-green-600 mt-0.5" />
                )}
                {notification.type === "order_delayed" && (
                  <AlertCircle className="w-4 h-4 text-orange-600 mt-0.5" />
                )}
                <div className="flex-1">
                  <p className="text-sm font-medium text-gray-800">
                    {notification.message}
                  </p>
                  <div className="flex items-center gap-1 mt-1">
                    <Clock className="w-3 h-3 text-gray-400" />
                    <span className="text-xs text-gray-500">
                      {new Date(notification.created_at).toLocaleTimeString()}
                    </span>
                  </div>
                </div>
              </div>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => dismissNotification(notification.id)}
                className="h-6 w-6 p-0 text-gray-400 hover:text-gray-600"
              >
                <X className="w-3 h-3" />
              </Button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\LiveOrdersComponent.tsx -----

'use client';

import React, { useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { RefreshCw, Clock, ChefHat, CheckCircle, XCircle } from 'lucide-react';
import Link from 'next/link';
import { OrderItem, OrderItemStatus } from '@/app/dashboard/orders/LiveOrders';
import { setOrderStatus } from '@/lib/api/orders';

interface LiveOrdersComponentProps {
  fetchLiveOrders: () => Promise<void>;
  refreshing: boolean;
  liveOrders: OrderItem[] | null;
  filteredOrders: OrderItem[] | null;
  activeStatus: OrderItemStatus | 'All';
  setActiveStatus: (status: OrderItemStatus | 'All') => void;
  formatDate: (dateString: string) => string;
  getTotalPrice: (orders: OrderItem[] | null) => number;
  errorMsg?: string | null;
}

const ETA_PRESETS = [10, 15, 20, 25, 30];

const LiveOrdersComponent: React.FC<LiveOrdersComponentProps> = ({
  fetchLiveOrders,
  refreshing,
  liveOrders,
  filteredOrders,
  activeStatus,
  setActiveStatus,
  formatDate,
  getTotalPrice,
  errorMsg,
}) => {
  const [updatingId, setUpdatingId] = useState<string | null>(null);
  const [etaChoice, setEtaChoice] = useState<Record<string, number>>({});

  const handleUpdate = async (orderId: string, status: OrderItemStatus, eta?: number | null) => {
    try {
      setUpdatingId(orderId);
      await setOrderStatus(orderId, status as any, eta ?? null);
      await fetchLiveOrders();
    } catch (e: any) {
      console.error('[update status]', e);
      alert(e?.message || 'Failed to update status');
    } finally {
      setUpdatingId(null);
    }
  };

  const getStatusIcon = (status: OrderItemStatus | null) => {
    switch (status) {
      case 'Pending': return <Clock className="h-4 w-4" />;
      case 'Confirmed': return <CheckCircle className="h-4 w-4" />;
      case 'Preparing': return <ChefHat className="h-4 w-4" />;
      case 'Ready': return <CheckCircle className="h-4 w-4" />;
      case 'Cancelled': return <XCircle className="h-4 w-4" />;
      default: return <Clock className="h-4 w-4" />;
    }
  };

  const getStatusVariant = (status: OrderItemStatus | null) => {
    switch (status) {
      case 'Cancelled': return 'destructive';
      case 'Confirmed':
      case 'Preparing':
      case 'Ready': return 'default';
      case 'Pending':
      default: return 'secondary';
    }
  };

  return (
    <div className="container mx-auto px-4 py-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-4">
        <div>
          <h1 className="text-2xl font-bold">Live Orders</h1>
          <p className="text-muted-foreground">Manage active orders in real-time</p>
        </div>
        <Button onClick={fetchLiveOrders} disabled={refreshing} variant="outline" className="flex items-center gap-2">
          <RefreshCw className={`h-4 w-4 ${refreshing ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      {errorMsg && (
        <div className="mb-4 rounded border border-destructive bg-destructive/10 px-3 py-2 text-sm text-destructive">
          {errorMsg}
        </div>
      )}

      {/* Summary */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <Card><CardHeader><CardTitle>Total Orders</CardTitle></CardHeader><CardContent>{liveOrders?.length || 0}</CardContent></Card>
        <Card><CardHeader><CardTitle>Pending</CardTitle></CardHeader><CardContent>{liveOrders?.filter(o=>o.status==='Pending').length || 0}</CardContent></Card>
        <Card><CardHeader><CardTitle>Total Value</CardTitle></CardHeader><CardContent>${getTotalPrice(liveOrders).toFixed(2)}</CardContent></Card>
      </div>

      {/* Tabs */}
      <Tabs value={activeStatus} onValueChange={(v)=>setActiveStatus(v as OrderItemStatus|'All')}>
        <TabsList className="mb-4 grid grid-cols-5">
          <TabsTrigger value="All">All</TabsTrigger>
          <TabsTrigger value="Pending">Pending</TabsTrigger>
          <TabsTrigger value="Confirmed">Confirmed</TabsTrigger>
          <TabsTrigger value="Preparing">Preparing</TabsTrigger>
          <TabsTrigger value="Ready">Ready</TabsTrigger>
        </TabsList>

        <div>
          {filteredOrders && filteredOrders.length > 0 ? (
            <div className="space-y-4">
              {filteredOrders.map((order) => {
                const isUpdating = updatingId === order.order.id;
                const eta = etaChoice[order.order.id] ?? 15;
                return (
                  <Card key={order.id}>
                    <CardHeader>
                      <div className="flex justify-between items-center">
                        <div>
                          {/* âœ… Show both Internal Short ID + Tracking Code */}
                          <CardTitle>
                            #{order.order.id.slice(-6)} â€¢ 
                            <Link
                              href={`/customer-end-pages/${order.order.restaurant.name.toLowerCase().replace(/\s+/g, '-')}/orders/${order.order.track_code}`}
                              className="text-blue-600 hover:underline ml-1"
                              target="_blank"
                            >
                              Code: {order.order.track_code}
                            </Link>
                            {order.order.table_number && ` â€¢ Table ${order.order.table_number}`}
                          </CardTitle>
                          <CardDescription>
                            {order.order.restaurant.name} â€¢ {formatDate(order.created_at)}
                          </CardDescription>
                        </div>
                        <Badge variant={getStatusVariant(order.status)} className="flex items-center gap-1">
                          {getStatusIcon(order.status)} {order.status}
                        </Badge>
                      </div>
                    </CardHeader>
                    <CardContent>
                      <div className="flex justify-between items-start mb-3">
                        <div>
                          <h3 className="font-semibold">{order.menu_item?.name}</h3>
                          <p className="text-sm text-muted-foreground">Qty: {order.quantity}</p>
                        </div>
                        <div className="text-right">
                          <p className="font-semibold">${(order.price * order.quantity).toFixed(2)}</p>
                          <p className="text-xs text-muted-foreground">${order.price.toFixed(2)} each</p>
                        </div>
                      </div>

                      {/* Actions */}
                      <div className="flex flex-wrap gap-2">
                        <Button
                          size="sm"
                          disabled={isUpdating || order.status !== 'Pending'}
                          onClick={() => handleUpdate(order.order.id, 'Confirmed')}
                        >
                          {isUpdating ? 'Updating...' : 'Confirm'}
                        </Button>

                        <div className="flex items-center gap-2">
                          <select
                            className="border rounded px-2 py-1 text-sm"
                            value={eta}
                            onChange={(e) => setEtaChoice((prev) => ({ ...prev, [order.order.id]: Number(e.target.value) }))}
                            disabled={isUpdating}
                          >
                            {ETA_PRESETS.map((m) => (
                              <option key={m} value={m}>{m} min</option>
                            ))}
                          </select>
                          <Button
                            size="sm"
                            disabled={isUpdating || (order.status !== 'Pending' && order.status !== 'Confirmed')}
                            onClick={() => handleUpdate(order.order.id, 'Preparing', eta)}
                          >
                            {isUpdating ? 'Updating...' : `Preparing (${eta}m)`}
                          </Button>
                        </div>

                        <Button
                          size="sm"
                          disabled={isUpdating || order.status !== 'Preparing'}
                          onClick={() => handleUpdate(order.order.id, 'Ready')}
                        >
                          {isUpdating ? 'Updating...' : 'Ready'}
                        </Button>

                        <Button
                          size="sm"
                          variant="destructive"
                          disabled={isUpdating || order.status === 'Ready'}
                          onClick={() => handleUpdate(order.order.id, 'Cancelled')}
                        >
                          {isUpdating ? 'Updating...' : 'Cancel'}
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-12">
              <div className="bg-muted rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
                <Clock className="h-8 w-8 text-muted-foreground" />
              </div>
              <h3 className="text-lg font-medium mb-2">No orders found</h3>
              <p className="text-muted-foreground">
                {activeStatus === 'All'
                  ? "You don't have any active orders at the moment."
                  : `You don't have any orders with status "${activeStatus}".`}
              </p>
            </div>
          )}
        </div>
      </Tabs>
    </div>
  );
};

export default LiveOrdersComponent;

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\LiveOrdersPanel.tsx -----

"use client";

import { useEffect, useMemo, useState } from "react";
import { createClient } from "@supabase/supabase-js";
import { RecentOrders } from "@/components/RecentOrders";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Bell, X } from "lucide-react";

interface Props {
  dateRange?: any;
}

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

type Order = {
  id: string;                 // uuid
  table_id: number | string;
  status: "Preparing" | "Ready" | "Served" | string;
  total_amount: number | string;
  created_at: string;
  estimated_time: number | string | null;
};

type OrderItem = {
  id: string;                 // uuid
  order_id: string;           // FK â†’ orders.id
  quantity: number;
  price: number | string;     // numeric comes back as string from PG
  created_at: string;
  menu_item: number;          // refers to a menu_items.id (int8)
};

export function LiveOrdersPanel({ dateRange }: Props) {
  const [liveOrders, setLiveOrders] = useState<Order[]>([]);
  const [newOrderCount, setNewOrderCount] = useState(0);
  const [isPulsing, setIsPulsing] = useState(false);

  // which order card is open (overlay)
  const [openOrderId, setOpenOrderId] = useState<string | null>(null);

  useEffect(() => {
    async function fetchOrders() {
      const { data, error } = await supabase
        .from("orders")
        .select("id, table_id, status, total_amount, created_at, estimated_time")
        .order("created_at", { ascending: false })
        .limit(12);

      if (!error && data) setLiveOrders(data as Order[]);
    }

    fetchOrders();

    // realtime: new orders
    const ch = supabase
      .channel("orders-insert")
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "orders" },
        (payload) => {
          setLiveOrders((prev) => [payload.new as Order, ...prev].slice(0, 12));
          setNewOrderCount((c) => c + 1);
          setIsPulsing(true);
          setTimeout(() => setIsPulsing(false), 3000);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(ch);
    };
  }, []);

  const getStatusColor = (status: string) => {
    switch (status) {
      case "Preparing": return "bg-yellow-100 text-yellow-800 border-yellow-200";
      case "Ready": return "bg-green-100 text-green-800 border-green-200";
      case "Served": return "bg-blue-100 text-blue-800 border-blue-200";
      default: return "bg-gray-100 text-gray-800 border-gray-200";
    }
  };

  // compute header stats safely (numeric may be string)
  const totals = useMemo(() => {
    const totalValue = liveOrders.reduce((s, o) => s + Number(o.total_amount || 0), 0);
    const readyCount = liveOrders.filter((o) => o.status === "completed").length;
    return { totalValue, readyCount };
  }, [liveOrders]);

  return (
    <div className="max-w-6xl mx-auto space-y-6">
      {/* Live Orders Header with Stats */}
      <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-blue-200 animate-slide-up">
        <CardHeader className="pb-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className={`p-2 rounded-full bg-blue-600 text-white transition-all duration-300 ${isPulsing ? "animate-pulse animate-glow" : ""}`}>
                <Bell className="w-5 h-5" />
              </div>
              <div>
                <CardTitle className="text-xl font-bold text-slate-800">Live Orders</CardTitle>
                <p className="text-slate-600 text-sm">Real-time order tracking</p>
              </div>
            </div>
            <div className="flex items-center gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">{liveOrders.length}</div>
                <div className="text-xs text-slate-600">Active Orders</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-green-600">{totals.readyCount}</div>
                <div className="text-xs text-slate-600">Ready to Serve</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">${totals.totalValue.toFixed(2)}</div>
                <div className="text-xs text-slate-600">Total Value</div>
              </div>
            </div>
          </div>
        </CardHeader>
      </Card>

      {/* Live Orders Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {liveOrders.map((order, index) => (
          <Card
            key={order.id}
            onClick={() => setOpenOrderId(order.id)}
            className={`relative cursor-pointer hover:shadow-lg transition-all duration-300 animate-slide-up ${
              index === 0 && newOrderCount > 0 ? "animate-pulse border-blue-300 animate-glow" : ""
            }`}
            style={{ animationDelay: `${index * 100}ms` }}
          >
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                  <span className="text-sm font-medium text-slate-600">#{order.id}</span>
                </div>
                <Badge variant="outline" className={getStatusColor(order.status)}>{order.status}</Badge>
              </div>
            </CardHeader>

            <CardContent className="space-y-3">
              <div className="flex items-center justify-between">
                <span className="text-slate-600 text-sm">Table:</span>
                <span className="font-medium">{order.table_id}</span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-slate-600 text-sm">Amount:</span>
                <span className="font-medium text-green-600">${Number(order.total_amount).toFixed(2)}</span>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-slate-600 text-sm">Time:</span>
                <span className="font-medium text-blue-600">{new Date(order.created_at).toLocaleTimeString()}</span>
              </div>
              {order.estimated_time && (
                <div className="flex items-center justify-between">
                  <span className="text-slate-600 text-sm">ETA:</span>
                  <span className="font-medium text-purple-600">{order.estimated_time}</span>
                </div>
              )}
            </CardContent>

            {/* Overlay with order_items (only for the clicked card) */}
            {openOrderId === order.id && (
              <OrderItemsOverlay
                orderId={order.id}
                onClose={(e) => {
                  e.stopPropagation();
                  setOpenOrderId(null);
                }}
              />
            )}
          </Card>
        ))}
      </div>

      {/* Recent Orders Section */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg font-semibold text-slate-800">Recent Order History</CardTitle>
        </CardHeader>
        <CardContent>
          <RecentOrders dateRange={dateRange} />
        </CardContent>
      </Card>
    </div>
  );
}

/* ---------- Overlay Component (fetches order_items by FK) ---------- */

function OrderItemsOverlay({
  orderId,
  onClose,
}: {
  orderId: string;
  onClose: (e: React.MouseEvent) => void;
}) {
  const [items, setItems] = useState<OrderItem[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let mounted = true;

    async function fetchItems() {
      setLoading(true);
      const { data, error } = await supabase
        .from("order_items")
        .select("id, order_id, quantity, price, created_at, menu_item")
        .eq("order_id", orderId)
        .order("created_at", { ascending: true });

      if (!error && mounted) setItems((data || []) as OrderItem[]);
      setLoading(false);
    }

    fetchItems();

    // realtime inserts for this order_id
    const channel = supabase
      .channel(`order-items-${orderId}`)
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "order_items", filter: `order_id=eq.${orderId}` },
        (payload) => setItems((prev) => [...prev, payload.new as OrderItem])
      )
      .subscribe();

    return () => {
      mounted = false;
      supabase.removeChannel(channel);
    };
  }, [orderId]);

  const orderTotal = items.reduce(
    (s, i) => s + Number(i.price || 0) * Number(i.quantity || 0),
    0
  );

  return (
    <div
      className="absolute inset-0 z-30 rounded-2xl bg-blue-200/95 backdrop-blur-md border border-slate-200 shadow-2xl p-4"
      onClick={(e) => e.stopPropagation()} // don't close when clicking inside
    >
      <div className="flex items-center justify-between mb-3">
        <div>
          <h3 className="text-base font-semibold text-slate-800">Items for Order #{orderId}</h3>
          <p className="text-xs text-slate-500">Live updates</p>
        </div>
        <button
          aria-label="Close"
          onClick={onClose}
          className="rounded-full p-1 hover:bg-slate-100"
        >
          <X className="w-5 h-5 text-slate-600" />
        </button>
      </div>

      {loading ? (
        <div className="text-sm text-slate-500">Loading itemsâ€¦</div>
      ) : items.length === 0 ? (
        <div className="text-sm text-slate-500">No items yet for this order.</div>
      ) : (
        <div className="max-h-60 overflow-auto space-y-2 pr-1">
          {items.map((it) => {
            const lineTotal = Number(it.price) * Number(it.quantity);
            return (
              <div
                key={it.id}
                className="flex items-center justify-between rounded-lg border border-slate-200 p-2"
              >
                <div className="text-sm">
                  <div className="font-medium">
                    {/* If you have a relation to menu_items, replace with the name */}
                    Item #{it.menu_item}
                  </div>
                  <div className="text-xs text-slate-500">
                    Qty: {it.quantity} â€¢ â‚¹{Number(it.price).toFixed(2)} each
                  </div>
                </div>
                <div className="text-sm font-semibold">â‚¹{lineTotal.toFixed(2)}</div>
              </div>
            );
          })}
        </div>
      )}

      <div className="mt-3 flex items-center justify-between border-t pt-3">
        <span className="text-sm text-slate-600">Items Total</span>
        <span className="text-base font-bold">â‚¹{orderTotal.toFixed(2)}</span>
      </div>
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\OfflineIndicator.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { WifiOff } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';

export default function OfflineIndicator() {
  const [isOffline, setIsOffline] = useState(false);

  useEffect(() => {
    const checkOnlineStatus = () => {
      setIsOffline(!navigator.onLine);
    };

    // Check initial status
    checkOnlineStatus();

    // Listen for online/offline events
    window.addEventListener('online', checkOnlineStatus);
    window.addEventListener('offline', checkOnlineStatus);

    return () => {
      window.removeEventListener('online', checkOnlineStatus);
      window.removeEventListener('offline', checkOnlineStatus);
    };
  }, []);

  if (!isOffline) {
    return null;
  }

  return (
    <Alert className="fixed top-0 left-0 right-0 z-50 bg-yellow-50 border-yellow-200 text-yellow-800">
      <WifiOff className="h-4 w-4" />
      <AlertDescription>
        You&apos;re currently offline. Some features may not be available.
      </AlertDescription>
    </Alert>
  );
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\OfflineStatusBar.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { Wifi, WifiOff, RefreshCw, Clock, CheckCircle } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { offlineSync } from '@/lib/offline/offlineSync';

export default function OfflineStatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingActionsCount, setPendingActionsCount] = useState(0);
  const [isSyncing, setIsSyncing] = useState(false);

  useEffect(() => {
    const checkOnlineStatus = () => {
      setIsOnline(navigator.onLine);
    };

    // Check initial status
    checkOnlineStatus();

    // Listen for online/offline events
    window.addEventListener('online', checkOnlineStatus);
    window.addEventListener('offline', checkOnlineStatus);

    // Check pending actions count
    const checkPendingActions = async () => {
      try {
        const count = await offlineSync.getPendingActionsCount();
        setPendingActionsCount(count);
      } catch (error) {
        console.error('Failed to check pending actions:', error);
      }
    };

    checkPendingActions();

    // Set up interval to check pending actions
    const interval = setInterval(checkPendingActions, 30000); // Check every 30 seconds

    return () => {
      window.removeEventListener('online', checkOnlineStatus);
      window.removeEventListener('offline', checkOnlineStatus);
      clearInterval(interval);
    };
  }, []);

  const handleSyncNow = async () => {
    if (isOnline && pendingActionsCount > 0) {
      setIsSyncing(true);
      try {
        const result = await offlineSync.syncPendingActions();
        console.log('Manual sync result:', result);
        
        // Update pending actions count
        const newCount = await offlineSync.getPendingActionsCount();
        setPendingActionsCount(newCount);
        
        // Show success message
        if (result.syncedActions > 0) {
          // You could use a toast notification here
          console.log(`Successfully synced ${result.syncedActions} actions`);
        }
      } catch (error) {
        console.error('Manual sync failed:', error);
      } finally {
        setIsSyncing(false);
      }
    }
  };

  // Don't show anything if online and no pending actions
  if (isOnline && pendingActionsCount === 0) {
    return null;
  }

  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 px-4 py-2 z-40">
      <div className="flex items-center justify-between max-w-7xl mx-auto">
        <div className="flex items-center gap-3">
          {/* Online/Offline Status */}
          <div className="flex items-center gap-2">
            {isOnline ? (
              <Wifi className="h-4 w-4 text-green-600" />
            ) : (
              <WifiOff className="h-4 w-4 text-red-600" />
            )}
            <span className="text-sm font-medium">
              {isOnline ? 'Online' : 'Offline'}
            </span>
          </div>

          {/* Pending Actions Indicator */}
          {pendingActionsCount > 0 && (
            <div className="flex items-center gap-2">
              <Clock className="h-4 w-4 text-yellow-600" />
              <Badge variant="secondary" className="text-xs">
                {pendingActionsCount} pending action{pendingActionsCount !== 1 ? 's' : ''}
              </Badge>
            </div>
          )}
        </div>

        {/* Sync Button */}
        {isOnline && pendingActionsCount > 0 && (
          <Button
            onClick={handleSyncNow}
            disabled={isSyncing}
            size="sm"
            variant="outline"
            className="flex items-center gap-2"
          >
            {isSyncing ? (
              <RefreshCw className="h-4 w-4 animate-spin" />
            ) : (
              <CheckCircle className="h-4 w-4" />
            )}
            {isSyncing ? 'Syncing...' : 'Sync Now'}
          </Button>
        )}
      </div>
    </div>
  );
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\RecentOrders.tsx -----

'use client';

import React, { useEffect, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Card, CardContent } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { supabase } from "@/lib/supabase/client";
import { getInitials } from "@/lib/utils";
import { Utensils } from "lucide-react";

// Define the shape of our order data, including the joined table data
type OrderWithDetails = {
  id: string;
  total_amount: number;
  created_at: string;
  status: 'pending' | 'confirmed' | 'preparing' | 'ready' | 'complete' | 'cancelled';
  tables: {
    table_number: string;
  } | null;
  restaurants: {
    restaurant_name: string;
  } | null;
};

// Helper function to determine badge color based on status
const getStatusColor = (status: string) => {
  switch (status) {
    case "ready":
    case "complete":
      return "bg-green-100 text-green-800 border-green-200";
    case "preparing":
      return "bg-blue-100 text-blue-800 border-blue-200";
    case "pending":
      return "bg-yellow-100 text-yellow-800 border-yellow-200";
    case "cancelled":
      return "bg-red-100 text-red-800 border-red-200";
    default:
      return "bg-gray-100 text-gray-800 border-gray-200";
  }
};

const OrderSkeleton = () => (
    <div className="flex items-center space-x-4">
      <Skeleton className="h-12 w-12 rounded-full" />
      <div className="space-y-2">
        <Skeleton className="h-4 w-[250px]" />
        <Skeleton className="h-4 w-[200px]" />
      </div>
    </div>
);


export function RecentOrders() {
  const [orders, setOrders] = useState<OrderWithDetails[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchRecentOrders = async () => {
      setLoading(true);
      setError(null);

      const { data, error } = await supabase
        .from('orders')
        .select(`
          id,
          total_amount,
          created_at,
          status,
          tables (table_number),
          restaurants (restaurant_name)
        `)
        .order('created_at', { ascending: false })
        .limit(5);

      if (error) {
        console.error("Error fetching recent orders:", error);
        setError("Could not fetch recent orders.");
      } else {
        setOrders(data as OrderWithDetails[]);
      }
      setLoading(false);
    };

    fetchRecentOrders();

    // Set up Supabase real-time subscription
    const channel = supabase
      .channel('public:orders')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'orders' },
        (payload) => {
          // When a new order comes in, prepend it to the list
          setOrders(prevOrders => [payload.new as OrderWithDetails, ...prevOrders].slice(0, 5));
        }
      )
      .subscribe();

    // Cleanup subscription on component unmount
    return () => {
      supabase.removeChannel(channel);
    };
  }, []);

  if (loading) {
    return (
        <div className="space-y-4">
            <OrderSkeleton />
            <OrderSkeleton />
            <OrderSkeleton />
        </div>
    );
  }

  if (error) {
    return <p className="text-red-500 text-center">{error}</p>;
  }

  return (
    <div className="space-y-4">
      {orders.length === 0 ? (
        <div className="text-center py-10">
            <Utensils className="mx-auto h-12 w-12 text-gray-400"/>
            <h3 className="mt-2 text-sm font-medium text-gray-900">No Recent Orders</h3>
            <p className="mt-1 text-sm text-gray-500">New orders will appear here in real-time.</p>
        </div>
      ) : (
        orders.map((order) => (
          <Card key={order.id} className="bg-white border border-gray-200 hover:shadow-md transition-shadow duration-300">
            <CardContent className="p-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-4">
                  <Avatar className="h-10 w-10">
                    <AvatarFallback className="bg-blue-100 text-blue-600 font-semibold">
                      {getInitials(order.tables?.table_number || 'T')}
                    </AvatarFallback>
                  </Avatar>
                  <div>
                    <p className="text-sm font-semibold text-gray-800">
                      Table {order.tables?.table_number || 'N/A'}
                    </p>
                    <p className="text-xs text-gray-500">
                      {new Date(order.created_at).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}
                    </p>
                  </div>
                </div>
                <div className="text-right">
                  <p className="font-bold text-gray-800">${Number(order.total_amount).toFixed(2)}</p>
                  <Badge variant="outline" className={`mt-1 text-xs capitalize ${getStatusColor(order.status)}`}>
                    {order.status}
                  </Badge>
                </div>
              </div>
            </CardContent>
          </Card>
        ))
      )}
    </div>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\RestaurantProfile.tsx -----

'use client';
import React, { useState, FormEvent } from 'react';
import { MapPin, Phone, Mail, User, Calendar, QrCode, CreditCard, Edit, Save, X, Loader2, CheckCircle, AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Restaurant, RestaurantProfileProps, ValidationErrors } from '@/types/restaurant'; // CORRECTED IMPORT
import { formatDate, getInitials } from '@/lib/utils'; // CORRECTED IMPORT

const RestaurantProfile: React.FC<RestaurantProfileProps> = ({ restaurant, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [notification, setNotification] = useState<{ type: 'success' | 'error'; message: string } | null>(null);

  const [formData, setFormData] = useState({
    owner_name: restaurant.owner_name,
    restaurant_name: restaurant.restaurant_name,
    email: restaurant.email,
    phone: restaurant.phone,
    address: restaurant.address,
    upi_id: restaurant.upi_id,
    logo_url: restaurant.logo_url || "",
  });

  const [errors, setErrors] = useState<ValidationErrors>({});

  const validateForm = (): boolean => {
    const newErrors: ValidationErrors = {};
    if (formData.owner_name.length < 2) newErrors.owner_name = "Owner name must be at least 2 characters";
    if (formData.restaurant_name.length < 2) newErrors.restaurant_name = "Restaurant name must be at least 2 characters";
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) newErrors.email = "Please enter a valid email address";
    if (!/^\+?[1-9]\d{9,14}$/.test(formData.phone)) newErrors.phone = "Please enter a valid phone number";
    if (formData.address.length < 10) newErrors.address = "Address must be at least 10 characters long";
    if (!/^[\w.-]+@[\w.-]+$/.test(formData.upi_id)) newErrors.upi_id = "Please enter a valid UPI ID (e.g., name@bank)";
    if (formData.logo_url && !/^https?:\/\/.+/.test(formData.logo_url)) newErrors.logo_url = "Please enter a valid URL";
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const showNotification = (type: 'success' | 'error', message: string) => {
    setNotification({ type, message });
    setTimeout(() => setNotification(null), 5000);
  };

  const handleEditToggle = () => {
    const isCurrentlyEditing = !isEditing;
    setIsEditing(isCurrentlyEditing);
    // If we are canceling the edit, reset the form data
    if (!isCurrentlyEditing) {
        setFormData({
            owner_name: restaurant.owner_name,
            restaurant_name: restaurant.restaurant_name,
            email: restaurant.email,
            phone: restaurant.phone,
            address: restaurant.address,
            upi_id: restaurant.upi_id,
            logo_url: restaurant.logo_url || "",
        });
        setErrors({});
    }
  };
  
  const handleInputChange = (field: keyof typeof formData, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear validation error for the field being edited
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };
  
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (!validateForm()) {
      showNotification('error', 'Please correct the errors before saving.');
      return;
    }
    if (!onUpdate) return;

    setIsLoading(true);
    setNotification(null);
    try {
      await onUpdate({
        ...formData,
        logo_url: formData.logo_url || null, // Convert empty string to null for the database
      });
      setIsEditing(false);
      showNotification('success', 'Your profile has been updated successfully!');
    } catch (error: any) {
      showNotification('error', `Update failed: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-4 sm:p-6">
      <div className="mx-auto max-w-6xl space-y-6">
        {notification && (
          <Alert variant={notification.type === 'error' ? 'destructive' : 'default'} className="animate-in fade-in">
            {notification.type === 'success' ? <CheckCircle className="h-4 w-4" /> : <AlertCircle className="h-4 w-4" />}
            <AlertDescription>{notification.message}</AlertDescription>
          </Alert>
        )}
        
        <Card className="overflow-hidden border-0 shadow-xl">
          <div className="bg-gradient-to-r from-orange-500 to-red-500 p-6 text-white">
            <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
              <div className="flex items-center gap-4">
                <Avatar className="h-20 w-20 border-4 border-white shadow-lg">
                  <AvatarImage src={formData.logo_url || ""} alt={formData.restaurant_name} />
                  <AvatarFallback className="text-orange-500 text-lg font-bold">
                    {getInitials(formData.restaurant_name)}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <h1 className="text-3xl font-bold tracking-tight">{formData.restaurant_name}</h1>
                  <p className="text-orange-100 text-lg">Owner: {formData.owner_name}</p>
                  <Badge variant="secondary" className="mt-2 bg-white/20 text-white">
                    <Calendar className="mr-1 h-3 w-3" />
                    Since {formatDate(restaurant.created_at)}
                  </Badge>
                </div>
              </div>
              <Button
                variant="secondary"
                size="sm"
                onClick={handleEditToggle}
                className="bg-white/20 hover:bg-white/30 border-0"
                disabled={isLoading}
              >
                {isEditing ? <X className="mr-2 h-4 w-4" /> : <Edit className="mr-2 h-4 w-4" />}
                {isEditing ? 'Cancel' : 'Edit Profile'}
              </Button>
            </div>
          </div>
        </Card>

        {isEditing ? (
            <Card className="shadow-lg animate-in fade-in">
                 <CardHeader>
                     <CardTitle>Edit Restaurant Information</CardTitle>
                     <CardDescription>Update your restaurant details below.</CardDescription>
                 </CardHeader>
                 <CardContent>
                     <form onSubmit={handleSubmit} className="space-y-6">
                         <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div className="space-y-2">
                                <label htmlFor="restaurant_name" className="text-sm font-medium">Restaurant Name</label>
                                <Input id="restaurant_name" value={formData.restaurant_name} onChange={e => handleInputChange('restaurant_name', e.target.value)} aria-invalid={!!errors.restaurant_name} />
                                {errors.restaurant_name && <p className="text-sm text-red-500">{errors.restaurant_name}</p>}
                            </div>
                            <div className="space-y-2">
                                <label htmlFor="owner_name" className="text-sm font-medium">Owner Name</label>
                                <Input id="owner_name" value={formData.owner_name} onChange={e => handleInputChange('owner_name', e.target.value)} aria-invalid={!!errors.owner_name} />
                                {errors.owner_name && <p className="text-sm text-red-500">{errors.owner_name}</p>}
                            </div>
                         </div>
                         <div className="space-y-2">
                            <label htmlFor="email" className="text-sm font-medium">Email Address</label>
                            <Input id="email" type="email" value={formData.email} onChange={e => handleInputChange('email', e.target.value)} aria-invalid={!!errors.email} />
                            {errors.email && <p className="text-sm text-red-500">{errors.email}</p>}
                         </div>
                         <div className="space-y-2">
                            <label htmlFor="phone" className="text-sm font-medium">Phone Number</label>
                            <Input id="phone" value={formData.phone} onChange={e => handleInputChange('phone', e.target.value)} aria-invalid={!!errors.phone} />
                            {errors.phone && <p className="text-sm text-red-500">{errors.phone}</p>}
                         </div>
                         <div className="space-y-2">
                            <label htmlFor="address" className="text-sm font-medium">Restaurant Address</label>
                            <Textarea id="address" value={formData.address} onChange={e => handleInputChange('address', e.target.value)} aria-invalid={!!errors.address} />
                            {errors.address && <p className="text-sm text-red-500">{errors.address}</p>}
                         </div>
                         <div className="space-y-2">
                            <label htmlFor="upi_id" className="text-sm font-medium">UPI ID</label>
                            <Input id="upi_id" value={formData.upi_id} onChange={e => handleInputChange('upi_id', e.target.value)} aria-invalid={!!errors.upi_id} />
                            {errors.upi_id && <p className="text-sm text-red-500">{errors.upi_id}</p>}
                         </div>
                         <div className="space-y-2">
                            <label htmlFor="logo_url" className="text-sm font-medium">Logo URL (Optional)</label>
                            <Input id="logo_url" value={formData.logo_url} onChange={e => handleInputChange('logo_url', e.target.value)} aria-invalid={!!errors.logo_url} />
                            {errors.logo_url && <p className="text-sm text-red-500">{errors.logo_url}</p>}
                         </div>
                         <Separator />
                         <div className="flex justify-end gap-3">
                            <Button type="button" variant="outline" onClick={handleEditToggle} disabled={isLoading}>Cancel</Button>
                            <Button type="submit" disabled={isLoading} className="bg-orange-500 hover:bg-orange-600">
                                {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Save className="mr-2 h-4 w-4" />}
                                Save Changes
                            </Button>
                         </div>
                     </form>
                 </CardContent>
            </Card>
        ) : (
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2">
                    <Card className="shadow-lg">
                        <CardHeader>
                            <CardTitle className="flex items-center gap-2 text-slate-800">
                                <User className="h-5 w-5 text-orange-500" /> Restaurant Information
                            </CardTitle>
                        </CardHeader>
                        <CardContent className="space-y-6 text-sm">
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
                                <div><p className="text-muted-foreground">Owner Name</p><p className="font-medium text-base">{restaurant.owner_name}</p></div>
                                <div><p className="text-muted-foreground">Phone</p><p className="font-medium text-base">{restaurant.phone}</p></div>
                            </div>
                            <div><p className="text-muted-foreground">Email Address</p><p className="font-medium text-base">{restaurant.email}</p></div>
                            <div><p className="text-muted-foreground">Address</p><p className="font-medium text-base">{restaurant.address}</p></div>
                            <div><p className="text-muted-foreground">UPI ID</p><Badge variant="outline">{restaurant.upi_id}</Badge></div>
                        </CardContent>
                    </Card>
                </div>
                <div className="space-y-6">
                    <Card className="shadow-lg">
                        <CardHeader>
                            <CardTitle className="flex items-center gap-2 text-slate-800">
                                <QrCode className="h-5 w-5 text-orange-500" /> Payment QR Code
                            </CardTitle>
                        </CardHeader>
                        <CardContent className="text-center">
                            <div className="inline-block p-4 bg-gray-50 rounded-lg border">
                                <img src={restaurant.qr_url} alt="Payment QR Code" className="w-40 h-40 mx-auto" />
                            </div>
                            <Badge variant="secondary" className="mt-4 font-mono">{restaurant.upi_id}</Badge>
                        </CardContent>
                    </Card>
                </div>
            </div>
        )}
      </div>
    </div>
  );
};

export default RestaurantProfile;


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\components\ServiceWorkerRegistration.tsx -----

'use client';

import { useEffect, useState } from 'react';
import { Download, X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { offlineSync } from '@/lib/offline/offlineSync';

interface BeforeInstallPromptEvent extends Event {
  prompt(): Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

export default function ServiceWorkerRegistration() {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showInstallPrompt, setShowInstallPrompt] = useState(false);
  const [isAppInstalled, setIsAppInstalled] = useState(false);
  const [canShowNotificationPrompt, setCanShowNotificationPrompt] = useState(false);

  useEffect(() => {
    // This entire block of code will only run on the client side.

    // Check if the app is already installed (PWA mode)
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsAppInstalled(true);
      return; // No need to show install prompts if already installed
    }

    // --- Service Worker Registration ---
    const registerServiceWorker = async () => {
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.register('/sw.js');
          console.log('Service Worker registered successfully:', registration);
        } catch (error) {
          console.error('Service Worker registration failed:', error);
        }
      }
    };
    registerServiceWorker();

    // --- PWA Install Prompt Logic ---
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      setShowInstallPrompt(true);
    };

    const handleAppInstalled = () => {
      setIsAppInstalled(true);
      setShowInstallPrompt(false);
      setDeferredPrompt(null);
    };

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', handleAppInstalled);

    // --- Offline Sync Logic ---
    const handleOnline = async () => {
      console.log('App is back online, checking for pending actions...');
      try {
        if (await offlineSync.hasPendingActions()) {
          const result = await offlineSync.syncPendingActions();
          console.log('Sync result:', result);
          if (result.syncedActions > 0 && Notification.permission === 'granted') {
            new Notification('Sync Complete', {
              body: `Successfully synced ${result.syncedActions} actions.`,
              icon: '/favicon.ico',
            });
          }
        }
      } catch (error) {
        console.error('Failed to sync pending actions:', error);
      }
    };
    window.addEventListener('online', handleOnline);

    // --- Notification Permission Check ---
    if ('Notification' in window && Notification.permission === 'default') {
      setCanShowNotificationPrompt(true);
    }

    // Cleanup listeners when the component unmounts
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('appinstalled', handleAppInstalled);
      window.removeEventListener('online', handleOnline);
    };
  }, []);

  const handleInstallClick = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === 'accepted') {
        console.log('User accepted the install prompt.');
      }
      setDeferredPrompt(null);
      setShowInstallPrompt(false);
    }
  };

  const requestNotificationPermission = async () => {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      if (permission === 'granted') {
        console.log('Notification permission granted.');
      }
      setCanShowNotificationPrompt(false); // Hide prompt regardless of choice
    }
  };

  if (isAppInstalled) {
    return null;
  }

  return (
    <>
      {/* PWA Install Prompt Card */}
      {showInstallPrompt && (
        <Card className="fixed bottom-4 right-4 w-80 z-50 shadow-lg animate-in fade-in">
          <CardHeader className="pb-3">
            <CardTitle className="text-lg flex items-center gap-2">
              <Download className="h-5 w-5" />
              Install App
            </CardTitle>
            <CardDescription>
              Get quick access and offline features.
            </CardDescription>
          </CardHeader>
          <CardContent className="flex gap-2">
            <Button onClick={handleInstallClick} className="flex-1">
              Install
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={() => setShowInstallPrompt(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </CardContent>
        </Card>
      )}

      {/* Notification Permission Card */}
      {canShowNotificationPrompt && (
        <Card data-notification-permission className="fixed bottom-4 left-4 w-80 z-50 shadow-lg animate-in fade-in">
          <CardHeader className="pb-3">
            <CardTitle className="text-lg">Enable Notifications</CardTitle>
            <CardDescription>
              Get notified about new orders and updates.
            </CardDescription>
          </CardHeader>
          <CardContent className="flex gap-2">
            <Button onClick={requestNotificationPermission} className="flex-1">
              Enable
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={() => setCanShowNotificationPrompt(false)}
            >
              <X className="h-4 w-4" />
            </Button>
          </CardContent>
        </Card>
      )}
    </>
  );
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\generateQR.ts -----

// src/lib/api/generateQR.ts
export const generateQR = async (restaurantId: string, tableNumber: string) => {
Â  const res = await fetch("/api/create-table", {
Â  Â  method: "POST",
Â  Â  headers: { "Content-Type": "application/json" },
Â  Â  body: JSON.stringify({ restaurantId, tableNumber }),
Â  });

Â  if (!res.ok) {
    const errorBody = await res.json();
    const errorText = errorBody.error || 'Unknown error';
    console.error("API call to create-table failed:", res.status, errorText);
    throw new Error(`Failed to generate QR: ${errorText}`);
  }

Â  const { url } = await res.json();
Â  return url;
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\menu.ts -----

import { supabase } from '@/lib/supabase/client';
import { MenuItem as MenuItemType } from '@/types/menu';

// Extend the base MenuItem type to include the required restaurant_id
export interface MenuItem extends MenuItemType {
  restaurant_id: string;
}

// Define the type for creating a new menu item
export type NewMenuItem = Omit<MenuItem, 'id'>;

// READ: Fetches menu items (will be automatically filtered by RLS)
export const getMenuItems = async (): Promise<MenuItem[]> => {
  const { data, error } = await supabase.from('menu_items').select('*');
  if (error) throw new Error(error.message);
  return data || [];
};

// CREATE: Adds a new menu item to the database
export const addMenuItem = async (itemData: NewMenuItem): Promise<MenuItem> => {
  const { data, error } = await supabase.from('menu_items').insert([itemData]).select().single();
  if (error) throw new Error(error.message);
  return data;
};

// UPDATE: Updates an existing menu item
export const updateMenuItem = async (id: number, updates: Partial<MenuItem>): Promise<MenuItem> => {
    const { data, error } = await supabase.from('menu_items').update(updates).eq('id', id).select().single();
    if (error) throw new Error(error.message);
    return data;
};

// DELETE: Deletes a menu item
export const deleteMenuItem = async (id: number): Promise<void> => {
    const { error } = await supabase.from('menu_items').delete().eq('id', id);
    if (error) throw new Error(error.message);
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\orders.ts -----

// src/lib/api/orders.ts
import { supabase } from '@/lib/supabase/client';
import { CartItem } from '@/app/customer-end-pages/store/cartStore';

export type OrderStatus = 'pending' | 'confirmed' | 'preparing' | 'ready' | 'complete' | 'cancelled';
export type CustomerOrderStatus = 'Pending' | 'Confirmed' | 'Preparing' | 'Ready' | 'Complete' | 'Cancelled';

const toDbStatus = (s: CustomerOrderStatus | OrderStatus): OrderStatus => {
  const map: Record<string, OrderStatus> = {
    Pending: 'pending', Confirmed: 'confirmed', Preparing: 'preparing',
    Ready: 'ready', Complete: 'complete', Cancelled: 'cancelled',
    pending: 'pending', confirmed: 'confirmed', preparing: 'preparing',
    ready: 'ready', complete: 'complete', cancelled: 'cancelled'
  };
  return map[s] ?? 'pending';
};

export type OrderRow = {
  id: string;
  restaurant_id: string;
  track_code: string;
  table_id: number | null;
  total_amount: number;
  status: OrderStatus;
  created_at: string;
  estimated_time: number | null;
  status_updated_at?: string | null;
};

/**
 * Creates a new order and its associated items in the database.
 * This is called from the customer-facing cart.
 * @returns An object with success status, trackCode, and restaurantSlug for redirection.
 */
export const submitOrder = async (
  cartItems: CartItem[],
  restaurantId: string,
  tableId: string,
  totalAmount: number
): Promise<{ success: boolean; trackCode: string; restaurantSlug: string }> => {
  
  const { data: orderData, error: orderError } = await supabase
    .from('orders')
    .insert({
      restaurant_id: restaurantId,
      table_id: parseInt(tableId, 10),
      total_amount: totalAmount,
      status: 'pending' as OrderStatus,
    })
    .select('id, track_code')
    .single();

  if (orderError || !orderData) {
    console.error('Error creating order record:', orderError);
    throw new Error('Could not create the order.');
  }

  const { id: orderId, track_code: trackCode } = orderData;

  const itemsToInsert = cartItems.map((item) => ({
    order_id: orderId,
    menu_item_id: item.id,
    quantity: item.quantity,
    price: item.price,
  }));
  
  const { error: itemsError } = await supabase.from('order_items').insert(itemsToInsert);

  if (itemsError) {
    console.error('Error inserting order items:', itemsError);
    await supabase.from('orders').delete().eq('id', orderId);
    throw new Error('Could not save the items for the order.');
  }

  const { data: restaurantData, error: slugError } = await supabase
    .from('restaurants')
    .select('slug')
    .eq('id', restaurantId)
    .single();

  if (slugError || !restaurantData) {
    console.error("Could not fetch restaurant slug for redirection:", slugError);
    throw new Error('Order placed, but could not retrieve redirect information.');
  }

  return { 
    success: true, 
    trackCode: trackCode, 
    restaurantSlug: restaurantData.slug 
  };
};

/**
 * Fetches a single order by its unique ID.
 */
export const getOrderById = async (orderId: string): Promise<OrderRow | null> => {
  const { data, error } = await supabase
    .from('orders')
    .select('*')
    .eq('id', orderId)
    .single();

  if (error) {
    console.error('getOrderById error:', error);
    return null;
  }
  return data as OrderRow;
};

const titleFor = (s: OrderStatus) => s.charAt(0).toUpperCase() + s.slice(1);

/**
 * Updates an order's status and optionally its ETA, then triggers a push notification.
 */
export const setOrderStatus = async (
  orderId: string,
  status: CustomerOrderStatus | OrderStatus,
  etaMinutes?: number | null
): Promise<OrderRow> => {
  const dbStatus = toDbStatus(status);

  const { data: updatedOrder, error } = await supabase
    .from('orders')
    .update({ status: dbStatus, estimated_time: etaMinutes ?? null })
    .eq('id', orderId)
    .select('track_code, restaurant_id')
    .single();

  if (error || !updatedOrder) {
    console.error('Error updating order status:', error);
    throw new Error('Failed to update order status.');
  }
  
  try {
    const { data: restaurantData } = await supabase
        .from('restaurants')
        .select('slug')
        .eq('id', updatedOrder.restaurant_id)
        .single();

    await fetch('/api/push/notify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        orderId,
        title: `Your order is now ${titleFor(dbStatus)}!`,
        body: etaMinutes ? `Estimated time remaining: ${etaMinutes} min.` : 'Status has been updated.',
        url: `/customer-end-pages/${restaurantData?.slug}/orders/${updatedOrder.track_code}`
      })
    });
  } catch (pushError) {
    console.warn('[Push Notification] Failed to send:', pushError);
  }

  return updatedOrder as OrderRow;
};

/**
 * Convenience function to update only the ETA of an order.
 */
export const setOrderEta = async (orderId: string, etaMinutes: number | null): Promise<boolean> => {
  const current = await getOrderById(orderId);
  if (!current) return false;
  
  await setOrderStatus(orderId, current.status, etaMinutes);
  return true;
};


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\public.ts -----

import { supabase } from "@/lib/supabase/client";
import { MenuItem } from "@/types/menu";
import { Restaurant } from "@/types/restaurant";

/**
 * Fetch basic restaurant details by slug
 */
export async function getRestaurantBySlug(
  slug: string
): Promise<{ id: string; restaurant_name: string; slug: string } | null> {
  const { data, error } = await supabase
    .from("restaurants")
    .select("id, restaurant_name, slug")
    .eq("slug", slug)
    // FIX: Use .maybeSingle() to prevent errors if multiple rows are found
    .maybeSingle();

  if (error) {
    console.error("Error fetching restaurant by slug:", error.message);
    return null;
  }

  return data;
}

/**
 * Get all details for the cart and page header.
 */
export async function getRestaurantDetails(slug: string): Promise<Restaurant | null> {
    const { data, error } = await supabase
        .from('restaurants')
        .select('*') // Select all details
        .eq('slug', slug)
        // FIX: Use .maybeSingle() here as well for consistency and safety
        .maybeSingle();

    if (error) {
        console.error("Error fetching full restaurant details:", error.message);
        return null;
    }
    return data;
}


/**
 * Fetch available menu items for a restaurant by slug
 */
export async function getPublicMenuItems(slug: string): Promise<MenuItem[]> {
  const restaurant = await getRestaurantBySlug(slug);
  if (!restaurant) return [];

  const { data, error } = await supabase
    .from("menu_items")
    .select("*")
    .eq("restaurant_id", restaurant.id)
    .eq("available", true);

  if (error) {
    console.error("Error fetching public menu items:", error.message);
    return [];
  }

  return data || [];
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\restaurants.ts -----

import { supabase } from '@/lib/supabase/client';

/**
 * Fetches the restaurant record for the currently logged-in user.
 * @returns A promise that resolves to an object with the restaurant's id and slug, or null if not found.
 */
export const getMyRestaurant = async (): Promise<{ id: string; slug: string } | null> => {
  // 1. Get the current user's session
  const { data: { session } } = await supabase.auth.getSession();
  if (!session?.user) {
    console.error("No user session found.");
    return null;
  }

  // 2. Use the user's ID to find their restaurant and select both id and slug
  const { data, error } = await supabase
    .from('restaurants')
    .select('id, slug') // Fetch both the id and the new slug column
    .eq('user_id', session.user.id)
    .single(); // We expect only one restaurant per user

  if (error) {
    console.error('Error fetching restaurant:', error.message);
    return null;
  }

  return data;
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\api\tables.ts -----

import { supabase } from '@/lib/supabase/client';

export interface Table {
  id: number;
  table_number: string;
  qr_code_url: string;
  restaurant_id: string;
}

export type NewTableData = {
  table_number: string;
  qr_code_url: string;
  restaurant_id: string;
};

// ADD 'export' HERE
export const getTables = async (): Promise<Table[]> => {
  const { data, error } = await supabase.from('tables').select('*').order('id');
  if (error) throw new Error(error.message);
  return data || [];
};

// ADD 'export' HERE
export const addTable = async (tableData: NewTableData): Promise<Table> => {
  const { data, error } = await supabase.from('tables').insert([tableData]).select().single();
  if (error) throw new Error(error.message);
  return data;
};

// ADD 'export' HERE
export const updateTable = async (id: number, updates: Partial<Table>): Promise<Table> => {
  const { data, error } = await supabase.from('tables').update(updates).eq('id', id).select().single();
  if (error) throw new Error(error.message);
  return data;
};

// ADD 'export' HERE
export const deleteTable = async (id: number): Promise<void> => {
  const { error } = await supabase.from('tables').delete().eq('id', id);
  if (error) throw new Error(error.message);
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\login.ts -----

import {supabase} from "../supabase/client"

const loginWithEmail = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })
  return { data, error }
}

export { loginWithEmail }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\logout.ts -----

import { supabase } from '../supabase/client'

export const logout = async () => {
  const { error } = await supabase.auth.signOut()
  return error
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\magiclink.ts -----


// src/lib/auth/magiclink.ts
import {supabase} from "../supabase/client"

export const sendMagicLink = async (email: string) => {
Â  const { data, error } = await supabase.auth.signInWithOtp({
Â  Â  email,
Â  Â  options: {
Â  Â  Â  shouldCreateUser: true,
Â  Â  Â  emailRedirectTo: `${window.location.origin}/dashboard`,
Â  Â  },
Â  })
Â  return { data, error }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\queries.ts -----

import { createServerClient } from '@supabase/ssr';

export async function getRestaurantDetails(cookies: any) {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) return null;

  const { data: restaurant, error } = await supabase
    .from('restaurants')
    .select('*')
    .eq('id', user.id)
    .single();

  if (error) {
    console.error('Error fetching restaurant:', error.message);
    return null;
  }

  return restaurant;
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\session.ts -----

import { supabase } from '../supabase/client'

export const getSession = async () => {
  const { data, error } = await supabase.auth.getSession()
  return { session: data?.session, error }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\auth\signup.ts -----

import { supabase } from '../supabase/client';

export interface SignUpData {
  email:          string;
  password:       string;
  owner_name:     string;
  restaurant_name: string;
  phone:          string;
  address:        string;
  upi_id:         string;
}

/**
 * Signs up a new user. The restaurant profile is created automatically by a database trigger.
 * @param formData The user and restaurant details.
 */
export const signUpWithRestaurant = async (formData: SignUpData) => {
  const { data, error } = await supabase.auth.signUp({
    email: formData.email,
    password: formData.password,
    // Pass the restaurant details as metadata. The trigger will use this.
    options: {
      data: {
        owner_name: formData.owner_name,
        restaurant_name: formData.restaurant_name,
        phone: formData.phone,
        address: formData.address,
        upi_id: formData.upi_id,
      }
    }
  });

  if (error) {
    console.error("Error signing up user:", error.message);
    throw new Error(`Could not sign up: ${error.message}`);
  }

  return data.user;
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\hooks\use-toast.ts -----

import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}



let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
}

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\hooks\useMenuItems.ts -----

'use client';

import { useState, useEffect, useCallback } from 'react';
import * as menuApi from '@/lib/api/menu';

export function useMenuItems() {
  const [menuItems, setMenuItems] = useState<menuApi.MenuItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchMenuItems = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await menuApi.getMenuItems();
      setMenuItems(data);
    } catch {
      setError('Could not load menu. Please try refreshing the page.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchMenuItems();
  }, [fetchMenuItems]);

  /**
   * Adds a new menu item for a specific restaurant.
   * @param newItemData The data from the form (name, price, etc.).
   * @param restaurantId The UUID of the restaurant this item belongs to.
   */
  const addMenuItem = async (newItemData: Omit<menuApi.NewMenuItem, 'restaurant_id'>, restaurantId: string) => {
    try {
      // Combine the form data with the restaurant ID to create a complete object
      const completeItemData = { ...newItemData, restaurant_id: restaurantId };
      const newItem = await menuApi.addMenuItem(completeItemData);
      setMenuItems(prev => [...prev, newItem]);
    } catch (err) {
      console.error("Failed to add item:", err);
      throw err; // Re-throw the error for the page to handle
    }
  };

  const updateMenuItem = async (id: number, updatedItemData: Partial<menuApi.MenuItem>) => {
    try {
      const updatedItem = await menuApi.updateMenuItem(id, updatedItemData);
      setMenuItems(prev => prev.map(item => (item.id === id ? updatedItem : item)));
    } catch (err) {
      console.error("Failed to update item:", err);
      throw err;
    }
  };

  const deleteMenuItem = async (id: number) => {
    try {
      await menuApi.deleteMenuItem(id);
      setMenuItems(prev => prev.filter(item => item.id !== id));
    } catch (err) {
      console.error("Failed to delete item:", err);
    }
  };

  return { menuItems, loading, error, addMenuItem, updateMenuItem, deleteMenuItem };
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\hooks\useOffline.ts -----

import { useState, useEffect } from 'react';
import { offlineSync } from '@/lib/offline/offlineSync';
import { offlineStorage } from '@/lib/offline/offlineStorage';

export interface OfflineStatus {
  isOnline: boolean;
  pendingActionsCount: number;
  isSyncing: boolean;
}

export interface OfflineActions {
  queueAction: (type: string, data: any) => Promise<string>;
  syncNow: () => Promise<void>;
  getPendingActions: () => Promise<any[]>;
  clearPendingActions: () => Promise<void>;
}

export function useOffline(): OfflineStatus & OfflineActions {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingActionsCount, setPendingActionsCount] = useState(0);
  const [isSyncing, setIsSyncing] = useState(false);

  useEffect(() => {
    const checkOnlineStatus = () => {
      setIsOnline(navigator.onLine);
    };

    // Check initial status
    checkOnlineStatus();

    // Listen for online/offline events
    window.addEventListener('online', checkOnlineStatus);
    window.addEventListener('offline', checkOnlineStatus);

    // Check pending actions count
    const checkPendingActions = async () => {
      try {
        const count = await offlineSync.getPendingActionsCount();
        setPendingActionsCount(count);
      } catch (error) {
        console.error('Failed to check pending actions:', error);
      }
    };

    checkPendingActions();

    // Set up interval to check pending actions
    const interval = setInterval(checkPendingActions, 30000); // Check every 30 seconds

    return () => {
      window.removeEventListener('online', checkOnlineStatus);
      window.removeEventListener('offline', checkOnlineStatus);
      clearInterval(interval);
    };
  }, []);

  const queueAction = async (type: string, data: any): Promise<string> => {
    try {
      const id = await offlineSync.queueAction({ type, data, retryCount: 0 });
      // Update pending actions count
      setPendingActionsCount(prev => prev + 1);
      return id;
    } catch (error) {
      console.error('Failed to queue action:', error);
      throw error;
    }
  };

  const syncNow = async (): Promise<void> => {
    if (isOnline && pendingActionsCount > 0) {
      setIsSyncing(true);
      try {
        const result = await offlineSync.syncPendingActions();
        console.log('Manual sync result:', result);
        
        // Update pending actions count
        const newCount = await offlineSync.getPendingActionsCount();
        setPendingActionsCount(newCount);
        
        return result;
      } catch (error) {
        console.error('Manual sync failed:', error);
        throw error;
      } finally {
        setIsSyncing(false);
      }
    }
  };

  const getPendingActions = async (): Promise<any[]> => {
    try {
      return await offlineSync.getPendingActions();
    } catch (error) {
      console.error('Failed to get pending actions:', error);
      return [];
    }
  };

  const clearPendingActions = async (): Promise<void> => {
    try {
      await offlineSync.clearAllPendingActions();
      setPendingActionsCount(0);
    } catch (error) {
      console.error('Failed to clear pending actions:', error);
      throw error;
    }
  };

  return {
    isOnline,
    pendingActionsCount,
    isSyncing,
    queueAction,
    syncNow,
    getPendingActions,
    clearPendingActions,
  };
}

// Hook for caching data
export function useOfflineCache<T>(key: string, ttl: number = 24 * 60 * 60 * 1000) {
  const [cachedData, setCachedData] = useState<T | null>(null);
  const [isLoading] = useState(false);

  const getCachedData = async (): Promise<T | null> => {
    try {
      return await offlineStorage.getCachedData(key);
    } catch (error) {
      console.error('Failed to get cached data:', error);
      return null;
    }
  };

  const setCachedData = async (data: T): Promise<void> => {
    try {
      await offlineStorage.setCachedData(key, data, ttl);
    } catch (error) {
      console.error('Failed to set cached data:', error);
    }
  };

  const removeCachedData = async (): Promise<void> => {
    try {
      await offlineStorage.removeCachedData(key);
    } catch (error) {
      console.error('Failed to remove cached data:', error);
    }
  };

  return {
    cachedData,
    isLoading,
    getCachedData,
    setCachedData,
    removeCachedData,
  };
}

// Hook for offline-first data fetching
export function useOfflineFirst<T>(
  key: string,
  fetchFunction: () => Promise<T>,
  ttl: number = 24 * 60 * 60 * 1000
) {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { getCachedData, setCachedData } = useOfflineCache<T>(key, ttl);

  const fetchData = async (forceRefresh = false) => {
    setIsLoading(true);
    setError(null);

    try {
      // Try to get cached data first (unless forcing refresh)
      if (!forceRefresh) {
        const cached = await getCachedData();
        if (cached) {
          setData(cached);
          setIsLoading(false);
          return;
        }
      }

      // Fetch fresh data
      const freshData = await fetchFunction();
      setData(freshData);
      
      // Cache the fresh data
      await setCachedData(freshData);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch data';
      setError(errorMessage);
      
      // If fetch failed, try to get cached data as fallback
      if (!forceRefresh) {
        const cached = await getCachedData();
        if (cached) {
          setData(cached);
          setError(null);
        }
      }
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [key]);

  return {
    data,
    isLoading,
    error,
    refetch: () => fetchData(true),
    refresh: () => fetchData(false),
  };
} 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\hooks\useProtectedRoute.ts -----

'use client'
import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { getSession } from '@/lib/auth/session'

export const useProtectedRoute = () => {
  const [loading, setLoading] = useState(true)
  const router = useRouter()

  useEffect(() => {
    const checkAuth = async () => {
      const { session } = await getSession()
      if (!session) {
        // CORRECTED: Redirect to the actual login page
        router.replace('/login') 
      } else {
        setLoading(false)
      }
    }
    checkAuth()
  }, [router]) // Added router to dependency array

  return { loading }
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\hooks\useTables.ts -----

// src/lib/hooks/useTables.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import * as tableApi from '@/lib/api/tables';
import { supabase } from '@/lib/supabase/client'; // Corrected import
import { generateQR } from '../api/generateQR';

export function useTables() {
Â  const [tables, setTables] = useState<tableApi.Table[]>([]);
Â  const [loading, setLoading] = useState(true);

Â  const fetchTables = useCallback(async () => {
Â  Â  try {
Â  Â  Â  setLoading(true);
Â  Â  Â  const data = await tableApi.getTables();
Â  Â  Â  setTables(data);
Â  Â  } catch (error) {
Â  Â  Â  console.error("Failed to fetch tables", error);
Â  Â  } finally {
Â  Â  Â  setLoading(false);
Â  Â  }
Â  }, []);

Â  useEffect(() => {
Â  Â  fetchTables();

    // Set up a real-time listener for any changes in the 'tables' table
Â  Â  const channel = supabase
Â  Â  Â  .channel('public:tables')
Â  Â  Â  .on(
Â  Â  Â  Â  'postgres_changes',
Â  Â  Â  Â  { event: '*', schema: 'public', table: 'tables' },
Â  Â  Â  Â  () => {
Â  Â  Â  Â  Â  console.log('Table change detected, refetching...');
Â  Â  Â  Â  Â  fetchTables();
Â  Â  Â  Â  }
Â  Â  Â  )
Â  Â  Â  .subscribe();
Â  Â  Â  
Â  Â  return () => {
Â  Â  Â  supabase.removeChannel(channel);
Â  Â  };
Â  }, [fetchTables]);

Â  const addTable = async (tableIdentifier: string, restaurantId: string) => {
Â  Â  try {
Â  Â  Â  // Use the consistent API helper
Â  Â  Â  await generateQR(restaurantId, tableIdentifier);
      // The real-time listener will handle updating the state, so no manual update is needed here.
Â  Â  } catch (error) {
Â  Â  Â  console.error("Error adding table:", error);
Â  Â  Â  throw error;
Â  Â  }
Â  };

Â  const deleteTable = async (id: number) => {
Â  Â  // Optimistic update: remove from UI immediately
Â  Â  setTables(prev => prev.filter(table => table.id !== id));
Â  Â  try {
Â  Â  Â  await tableApi.deleteTable(id);
Â  Â  } catch (error) {
Â  Â  Â  console.error("Failed to delete table, rolling back UI change.", error);
Â  Â  Â  // Rollback on failure
Â  Â  Â  fetchTables();
Â  Â  }
Â  };

Â  return { tables, loading, addTable, deleteTable };
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\offline\offlineStorage.ts -----

// src/lib/offline/offlineStorage.ts

export interface PendingAction {
  id: string;
  type: 'create_order' | 'update_menu' | 'delete_menu_item' | 'update_profile';
  data: any;
  timestamp: number;
  retryCount: number;
}

export interface CachedData {
  key: string;
  data: any;
  timestamp: number;
  expiresAt: number;
}

class OfflineStorage {
  private dbName = 'QuickBiteOfflineDB';
  private version = 1;
  private db: IDBDatabase | null = null;
  private initPromise: Promise<void> | null = null;

  /**
   * Initializes the IndexedDB database. This method is safe to call on both server and client.
   * It ensures the database connection is only attempted in a browser environment.
   */
  private init(): Promise<void> {
    // If we're on the server, return a resolved promise immediately.
    if (typeof window === 'undefined' || !window.indexedDB) {
      return Promise.resolve();
    }
    
    // Use a singleton promise to ensure initialization only runs once.
    if (!this.initPromise) {
      this.initPromise = new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, this.version);

        request.onerror = () => {
          console.error("IndexedDB error:", request.error);
          reject(request.error);
        };

        request.onsuccess = () => {
          this.db = request.result;
          resolve();
        };

        request.onupgradeneeded = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;

          if (!db.objectStoreNames.contains('pendingActions')) {
            const pendingStore = db.createObjectStore('pendingActions', { keyPath: 'id' });
            pendingStore.createIndex('type', 'type', { unique: false });
            pendingStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
          if (!db.objectStoreNames.contains('cachedData')) {
            const cacheStore = db.createObjectStore('cachedData', { keyPath: 'key' });
            cacheStore.createIndex('expiresAt', 'expiresAt', { unique: false });
          }
        };
      });
    }
    return this.initPromise;
  }

  private async getStore(storeName: 'pendingActions' | 'cachedData', mode: IDBTransactionMode): Promise<IDBObjectStore | null> {
    await this.init();
    if (!this.db) {
      return null;
    }
    return this.db.transaction(storeName, mode).objectStore(storeName);
  }

  async addPendingAction(action: Omit<PendingAction, 'id' | 'timestamp'>): Promise<string> {
    const store = await this.getStore('pendingActions', 'readwrite');
    if (!store) throw new Error("Database not available in this environment.");
    
    const id = crypto.randomUUID();
    const pendingAction: PendingAction = { ...action, id, timestamp: Date.now() };

    return new Promise((resolve, reject) => {
      const request = store.add(pendingAction);
      request.onsuccess = () => resolve(id);
      request.onerror = () => reject(request.error);
    });
  }

  async getPendingActions(): Promise<PendingAction[]> {
    const store = await this.getStore('pendingActions', 'readonly');
    if (!store) return []; // Gracefully return empty array on server.

    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  async removePendingAction(id: string): Promise<void> {
    const store = await this.getStore('pendingActions', 'readwrite');
    if (!store) throw new Error("Database not available.");

    return new Promise((resolve, reject) => {
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

// Export a single instance for the application to use.
export const offlineStorage = new OfflineStorage();

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\offline\offlineSync.ts -----

import { offlineStorage, PendingAction } from './offlineStorage';

export interface SyncResult {
  success: boolean;
  syncedActions: number;
  failedActions: number;
  errors: string[];
}

export class OfflineSync {
  private isSyncing = false;
  private syncQueue: (() => Promise<void>)[] = [];

  // Add an action to be synced when online
  async queueAction(action: Omit<PendingAction, 'id' | 'timestamp'>): Promise<string> {
    try {
      const id = await offlineStorage.addPendingAction(action);
      console.log('Action queued for sync:', action.type, id);
      return id;
    } catch (error) {
      console.error('Failed to queue action:', error);
      throw error;
    }
  }

  // Process all pending actions when coming back online
  async syncPendingActions(): Promise<SyncResult> {
    if (this.isSyncing) {
      return { success: false, syncedActions: 0, failedActions: 0, errors: ['Sync already in progress'] };
    }

    this.isSyncing = true;
    const result: SyncResult = {
      success: true,
      syncedActions: 0,
      failedActions: 0,
      errors: []
    };

    try {
      const pendingActions = await offlineStorage.getPendingActions();
      console.log(`Syncing ${pendingActions.length} pending actions`);

      for (const action of pendingActions) {
        try {
          await this.processAction(action);
          await offlineStorage.removePendingAction(action.id);
          result.syncedActions++;
          console.log(`Successfully synced action: ${action.type}`);
        } catch (error) {
          result.failedActions++;
          const errorMessage = `Failed to sync ${action.type}: ${error}`;
          result.errors.push(errorMessage);
          console.error(errorMessage);

          // Update retry count
          const newRetryCount = action.retryCount + 1;
          if (newRetryCount >= 3) {
            // Remove action after 3 failed attempts
            await offlineStorage.removePendingAction(action.id);
            console.log(`Removed action after ${newRetryCount} failed attempts: ${action.type}`);
          } else {
            await offlineStorage.updatePendingActionRetryCount(action.id, newRetryCount);
          }
        }
      }
    } catch (error) {
      result.success = false;
      result.errors.push(`Sync process failed: ${error}`);
      console.error('Sync process failed:', error);
    } finally {
      this.isSyncing = false;
    }

    return result;
  }

  // Process individual action based on type
  private async processAction(action: PendingAction): Promise<void> {
    switch (action.type) {
      case 'create_order':
        await this.syncCreateOrder(action.data);
        break;
      case 'update_menu':
        await this.syncUpdateMenu(action.data);
        break;
      case 'delete_menu_item':
        await this.syncDeleteMenuItem(action.data);
        break;
      case 'update_profile':
        await this.syncUpdateProfile(action.data);
        break;
      default:
        throw new Error(`Unknown action type: ${action.type}`);
    }
  }

  // Sync order creation
  private async syncCreateOrder(data: any): Promise<void> {
    // This would typically call your API endpoint
    const response = await fetch('/api/orders', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`Failed to create order: ${response.statusText}`);
    }
  }

  // Sync menu updates
  private async syncUpdateMenu(data: any): Promise<void> {
    const response = await fetch(`/api/menu/${data.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`Failed to update menu: ${response.statusText}`);
    }
  }

  // Sync menu item deletion
  private async syncDeleteMenuItem(data: any): Promise<void> {
    const response = await fetch(`/api/menu/${data.id}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      throw new Error(`Failed to delete menu item: ${response.statusText}`);
    }
  }

  // Sync profile updates
  private async syncUpdateProfile(data: any): Promise<void> {
    const response = await fetch('/api/profile', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`Failed to update profile: ${response.statusText}`);
    }
  }

  // Check if there are pending actions
  async hasPendingActions(): Promise<boolean> {
    const actions = await offlineStorage.getPendingActions();
    return actions.length > 0;
  }

  // Get count of pending actions
  async getPendingActionsCount(): Promise<number> {
    const actions = await offlineStorage.getPendingActions();
    return actions.length;
  }

  // Get pending actions by type
  async getPendingActionsByType(type: string): Promise<PendingAction[]> {
    return await offlineStorage.getPendingActions(type);
  }

  // Clear all pending actions (useful for testing or reset)
  async clearAllPendingActions(): Promise<void> {
    const actions = await offlineStorage.getPendingActions();
    for (const action of actions) {
      await offlineStorage.removePendingAction(action.id);
    }
  }

  // Add to sync queue for background processing
  addToSyncQueue(syncFunction: () => Promise<void>): void {
    this.syncQueue.push(syncFunction);
  }

  // Process sync queue
  async processSyncQueue(): Promise<void> {
    while (this.syncQueue.length > 0) {
      const syncFunction = this.syncQueue.shift();
      if (syncFunction) {
        try {
          await syncFunction();
        } catch (error) {
          console.error('Failed to process sync queue item:', error);
        }
      }
    }
  }
}

// Export singleton instance
export const offlineSync = new OfflineSync(); 

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\supabase\client.ts -----

// Browser-side Supabase client (for client components)
import { createBrowserClient } from '@supabase/ssr';

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// Simple exported instance (use in most client components)
export const supabase = createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Factory if you prefer isolated instances
export function createClient() {
  return createBrowserClient(SUPABASE_URL, SUPABASE_ANON_KEY);
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\supabase\server.ts -----

// Server-side Supabase client (Next.js App Router)
import { cookies } from 'next/headers';
import { createServerClient as createSupabaseServerClient } from '@supabase/ssr';

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export async function createServerClient() {
  // âœ… Await cookies in Next.js App Router
  const cookieStore = await cookies();

  return createSupabaseServerClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      set(name: string, value: string, options: any) {
        cookieStore.set({ name, value, ...options });
      },
      remove(name: string, options: any) {
        cookieStore.set({ name, value: '', ...options, maxAge: 0 });
      },
    },
  });
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\utils\image-compressor.ts -----

// src/lib/utils/image-compressor.ts

import imageCompression from 'browser-image-compression';

/**
 * Compresses an image file in the browser.
 * @param file The image file to compress.
 * @returns A promise that resolves with the compressed file.
 */
export const compressImage = async (file: File): Promise<File> => {
  const options = {
    maxSizeMB: 1,          // Max file size in MB
    maxWidthOrHeight: 1024,  // Max width or height
    useWebWorker: true,    // Use web worker for better performance
  };

  try {
    console.log(`Original file size: ${(file.size / 1024 / 1024).toFixed(2)} MB`);
    
    const compressedFile = await imageCompression(file, options);
    
    console.log(`Compressed file size: ${(compressedFile.size / 1024 / 1024).toFixed(2)} MB`);
    
    return compressedFile;
  } catch (error) {
    console.error('Image compression failed:', error);
    // Re-throw the error to be handled by the calling function
    throw new Error('Could not compress the selected image.');
  }
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\utils\notifications.ts -----

// Local (in-tab) fallback notifications
export function notifyLocal(title: string, body?: string) {
  if (typeof window === 'undefined' || !('Notification' in window)) return;
  if (Notification.permission === 'granted') {
    try { new Notification(title, { body }); } catch {}
  }
}

async function ensurePermission() {
  if (typeof window === 'undefined' || !('Notification' in window)) return false;
  if (Notification.permission === 'granted') return true;
  if (Notification.permission === 'denied') return false;
  const res = await Notification.requestPermission();
  return res === 'granted';
}

export async function registerPushForOrder(orderId: string) {
  if (typeof window === 'undefined') return;
  const ok = await ensurePermission();
  if (!ok) return;

  if (!('serviceWorker' in navigator) || !('PushManager' in window)) return;

  // Register SW once (no-op if already registered)
  let reg = await navigator.serviceWorker.getRegistration();
  if (!reg) {
    try { reg = await navigator.serviceWorker.register('/sw.js'); } catch { return; }
  }

  const vapidPubKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY;
  if (!vapidPubKey) return;

  const existing = await reg.pushManager.getSubscription();
  if (existing) {
    await saveSubscription(existing, orderId);
    return;
  }

  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(vapidPubKey)
  });

  await saveSubscription(sub, orderId);
}

function urlBase64ToUint8Array(base64String: string) {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

async function saveSubscription(subscription: PushSubscription, orderId: string) {
  const body = JSON.stringify({ orderId, subscription });
  await fetch('/api/push/subscribe', {
    method: 'POST', headers: { 'Content-Type': 'application/json' }, body
  });
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\uploadthing.ts -----

// src/lib/uploadthing.ts

import { generateReactHelpers } from "@uploadthing/react";
import type { OurFileRouter } from "@/app/api/uploadthing/core";

export const { useUploadThing, uploadFiles } = generateReactHelpers<OurFileRouter>();

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\lib\utils.ts -----

// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export const formatDate = (dateString: string): string => {
  return new Date(dateString).toLocaleDateString("en-IN", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
};

export const getInitials = (name: string): string => {
  if (!name) return '';
  return name
    .split(" ")
    .map((word) => word.charAt(0))
    .join("")
    .toUpperCase()
    .slice(0, 2);
};

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\types\menu.ts -----

// src/types/menu.ts

export type MenuCategory = 'starters' | 'mains' | 'desserts' | 'drinks';

export interface MenuItem {
  id: number;
  name: string;
  description: string;
  price: number;
  // FIX: The category is used in the app, so it should be part of the type.
  // Making it optional to handle cases where it might be null.
  category?: MenuCategory;
  photo_url?: string;
  available: boolean;
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\types\restaurant.ts -----

export interface Restaurant {
  id: string;
  restaurant_name: string;
  slug: string;
  user_id: string;
  created_at: string;
  updated_at?: string;
  description?: string;
  address?: string;
  phone?: string;
  email?: string;
  website?: string;
  logo_url?: string;
  banner_url?: string;
  is_active?: boolean;
}


----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\src\types\supabase.ts -----

// src/types/supabase.ts

// This file is intended to hold TypeScript types generated from your Supabase schema.
// You can generate these types by running the following command in your terminal:
// npx supabase gen types typescript --project-id YOUR_PROJECT_ID > src/types/supabase.ts
//
// Replace YOUR_PROJECT_ID with your actual Supabase project ID.
// This ensures that your application's types are always in sync with your database schema.

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export interface Database {
  // This would be populated by the generation script
}

----- D:\01--PROJECTS--APPROTECH\Quick_Bite_Qr\next.config.ts -----

/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'uploadthing.com',
      },
      {
        protocol: 'https',
        hostname: 'utfs.io',
      },
    ],
    // This is the part that fixes the preview
    dangerouslyAllowSVG: true,
    contentDispositionType: 'attachment',
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
    unoptimized: true, // Add this line
  },
  // PWA and offline support configuration
  async headers() {
    return [
      {
        source: '/sw.js',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=0, must-revalidate',
          },
          {
            key: 'Service-Worker-Allowed',
            value: '/',
          },
        ],
      },
      {
        source: '/manifest.json',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=0, must-revalidate',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;
